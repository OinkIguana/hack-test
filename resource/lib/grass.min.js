var grass =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-prim
 */



module.exports = (_core, opts) => {
    if (opts === undefined) {
        opts = {};
    }

    const _prim = __webpack_require__(24)(_core);

    if (opts.sugar) {
        const _sugar = __webpack_require__(25)(_core, _prim);
        _core.extendParser(_sugar);
    }

    return Object.freeze({
        map              : _prim.map,
        fmap             : _prim.fmap,
        pure             : _prim.pure,
        return           : _prim.pure,
        ap               : _prim.ap,
        left             : _prim.left,
        right            : _prim.right,
        bind             : _prim.bind,
        then             : _prim.then,
        and              : _prim.then,
        fail             : _prim.fail,
        tailRecM         : _prim.tailRecM,
        ftailRecM        : _prim.ftailRecM,
        mzero            : _prim.mzero,
        mplus            : _prim.mplus,
        or               : _prim.mplus,
        label            : _prim.label,
        labels           : _prim.labels,
        hidden           : _prim.hidden,
        unexpected       : _prim.unexpected,
        tryParse         : _prim.tryParse,
        try              : _prim.tryParse,
        lookAhead        : _prim.lookAhead,
        reduceMany       : _prim.reduceMany,
        many             : _prim.many,
        skipMany         : _prim.skipMany,
        tokens           : _prim.tokens,
        token            : _prim.token,
        tokenPrim        : _prim.tokenPrim,
        getParserState   : _prim.getParserState,
        setParserState   : _prim.setParserState,
        updateParserState: _prim.updateParserState,
        getConfig        : _prim.getConfig,
        setConfig        : _prim.setConfig,
        getInput         : _prim.getInput,
        setInput         : _prim.setInput,
        getPosition      : _prim.getPosition,
        setPosition      : _prim.setPosition,
        getState         : _prim.getState,
        setState         : _prim.setState
    });
};


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Grass-JS / vm.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        Nil,
        Cons,
        nil,
        listFromArray,

        Pair,
        pair,

        Inst,
        Abs,
        App,

        RuntimeError,
        VM
    });
}

const co = __webpack_require__(7);

// cons list
class Nil {
    constructor() {
    }

    toString() {
        return "nil";
    }

    isNil() {
        return true;
    }

    car() {
        throw new Error("nil");
    }

    cdr() {
        throw new Error("nil");
    }

    at() {
        throw new Error("nil");
    }

    cons(car) {
        return new Cons(car, this);
    }
}

class Cons {
    constructor(car, cdr) {
        this._car = car;
        this._cdr = cdr;
    }

    toString() {
        return this._car.toString() + " :: " + this._cdr.toString();
    }

    isNil() {
        return false;
    }

    car() {
        return this._car;
    }

    cdr() {
        return this._cdr;
    }

    at(n) {
        let c = this;
        while (n > 0) {
            c = c.cdr();
            n -= 1;
        }
        return c.car();
    }

    cons(car) {
        return new Cons(car, this);
    }
}

const nil = new Nil();

function listFromArray(arr) {
    let list = nil;
    const len  = arr.length;
    for (let i = len - 1; i >= 0; i--) {
        list = list.cons(arr[i]);
    }
    return list;
}

// pair
class Pair {
    constructor(fst, snd) {
        this._fst = fst;
        this._snd = snd;
    }

    toString() {
        return "(" + this._fst.toString() + ", " + this._snd.toString() + ")";
    }

    fst() {
        return this._fst;
    }

    snd() {
        return this._snd;
    }
}

function pair(fst, snd) {
    return new Pair(fst, snd);
}

// values
class Func {
    constructor(code, env) {
        this.code = code;
        this.env  = env;
    }

    toString() {
        return "Func[" + this.code.toString() + ", " + this.env.toString() + "]";
    }
}

class Char {
    constructor(code) {
        this.code = code;
    }

    toString() {
        return "'" + String.fromCharCode(this.code) + "'";
    }

    succ() {
        return new Char((this.code + 1) % 0x100);
    }
}

class Prim {
    constructor(name, func) {
        this.name = name;
        this.func = func;
    }

    toString() {
        return this.name;
    }
}

// instructions
class Inst {
    constructor(pos) {
        this.pos = pos;
    }
}

class App extends Inst {
    constructor(pos, func, arg) {
        super(pos);
        this.func = func;
        this.arg  = arg;
    }

    toString() {
        return "(" + this.func.toString() + " " + this.arg.toString() + ")";
    }
}

class Abs extends Inst {
    constructor(pos, arity, body) {
        super(pos);
        this.arity = arity;
        this.body  = body;
    }

    toString() {
        return "<" + this.arity.toString() + ": " + this.body.toString() + ">";
    }

    decr() {
        return new Abs(this.pos, this.arity - 1, this.body);
    }
}

// virtual machine
class RuntimeError extends Error {
    constructor(trace, message) {
        super(message);
        this.name  = this.constructor.name;
        this.trace = trace;
    }

    addTrace(trace) {
        return new RuntimeError(trace.concat(this.trace), this.message);
    }

    toString() {
        const traceStr = this.trace.map(t => t.toString() + ":\n").join("");
        return this.name + ": " + traceStr + this.message;
    }
}

const POS_VM = "VM";

const TRUE = new Func(
    nil.cons(new Abs(POS_VM, 1, nil.cons(new App(POS_VM, 2, 1)))),
    nil.cons(new Func(nil, nil))
);
const FALSE = new Func(
    nil.cons(new Abs(POS_VM, 1, nil)),
    nil
);
const SUCC = new Prim("Succ", x => {
    if (x instanceof Char) {
        return x.succ();
    }
    else {
        throw new RuntimeError(["Succ"], "not a character");
    }
});
const LOWER_W = new Char(119);

class State {
    constructor(code, env, dump) {
        this.code = code;
        this.env  = env;
        this.dump = dump;
    }

    clone() {
        return new State(this.code, this.env, this.dump);
    }
}

class VM {
    constructor(code, input, output) {
        const IN = new Prim("In", x => {
            const res = input();
            if (res instanceof Promise) {
                return input().then(
                        c => new Char(c),
                        () => x
                    );
            }
            else if (res !== undefined) {
                return new Char(res);
            }
            else {
                return x;
            }
        });
        const OUT = new Prim("Out", x => {
            if (x instanceof Char) {
                output(x.code);
                return x;
            }
            else {
                throw new RuntimeError(["Out"], "not a character");
            }
        });
        this.state = new State(
            code,
            nil.cons(IN).cons(LOWER_W).cons(SUCC).cons(OUT),
            nil.cons(pair(nil, nil)).cons(pair(nil.cons(new App(POS_VM, 0, 0)), nil))
        );
    }

    run(debug) {
        const state = this.state.clone();
        const trace = [];
        return co(function* () {
            while (true) {
                if (state.code.isNil()) {
                    if (!state.env.isNil() && state.env.cdr().isNil() && state.dump.isNil()) {
                        return state.env.car();
                    }
                    else if (!state.env.isNil() && !state.dump.isNil()) {
                        const f = state.env.car();
                        const d = state.dump.car();
                        state.code = d.fst();
                        state.env  = d.snd().cons(f);
                        state.dump = state.dump.cdr();
                        if (debug) {
                            trace.pop();
                        }
                    }
                    else {
                        throw new RuntimeError([POS_VM], "illegal state")
                            .addTrace(trace);
                    }
                }
                else {
                    const inst = state.code.car();
                    if (inst instanceof App) {
                        let ff;
                        let fa;
                        try {
                            ff = state.env.at(inst.func);
                        }
                        catch (_) {
                            throw new RuntimeError(
                                [inst.pos],
                                "function out of bounds: " + (inst.func + 1).toString()
                            ).addTrace(trace);
                        }
                        try {
                            fa = state.env.at(inst.arg);
                        }
                        catch (_) {
                            throw new RuntimeError(
                                [inst.pos],
                                "argument out of bounds: " + (inst.arg + 1).toString()
                            ).addTrace(trace);
                        }
                        if (ff instanceof Func) {
                            if (state.code.cdr().isNil() && !state.dump.isNil()) {
                                // tail call optimization
                                if (debug) {
                                    trace.push(inst.pos);
                                }
                                state.code = ff.code;
                                state.env  = ff.env.cons(fa);
                            }
                            else {
                                if (debug) {
                                    trace.push(inst.pos);
                                }
                                state.dump = state.dump.cons(pair(state.code.cdr(), state.env));
                                state.code = ff.code;
                                state.env  = ff.env.cons(fa);
                            }
                        }
                        else if (ff instanceof Char) {
                            if (debug) {
                                trace.push(inst.pos);
                            }
                            if (fa instanceof Char && ff.code === fa.code) {
                                state.code = state.code.cdr();
                                state.env  = state.env.cons(TRUE);
                            }
                            else {
                                state.code = state.code.cdr();
                                state.env  = state.env.cons(FALSE);
                            }
                            if (debug) {
                                trace.pop();
                            }
                        }
                        else if (ff instanceof Prim) {
                            if (debug) {
                                trace.push(inst.pos);
                            }
                            try {
                                let res = ff.func(fa);
                                if (res instanceof Promise) {
                                    res = yield res;
                                }
                                state.code = state.code.cdr();
                                state.env  = state.env.cons(res);
                            }
                            catch (error) {
                                if (error instanceof RuntimeError) {
                                    throw error.addTrace(trace);
                                }
                                else {
                                    throw error;
                                }
                            }
                            if (debug) {
                                trace.pop();
                            }
                        }
                    }
                    else if (inst instanceof Abs) {
                        if (inst.arity === 1) {
                            state.code = state.code.cdr();
                            state.env  = state.env.cons(new Func(inst.body, state.env));
                        }
                        else {
                            state.code = state.code.cdr();
                            state.env  = state.env.cons(new Func(nil.cons(inst.decr()), state.env));
                        }
                    }
                }
            }
        });
    }
}

end();


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-combinators
 */



module.exports = (_core, opts) => {
    if (opts === undefined) {
        opts = {};
    }

    const _prim        = __webpack_require__(0)(_core);
    const _combinators = __webpack_require__(11)(_core, _prim);

    if (opts.sugar) {
        const _sugar = __webpack_require__(12)(_core, _prim, _combinators);
        _core.extendParser(_sugar);
    }

    return Object.freeze({
        choice        : _combinators.choice,
        option        : _combinators.option,
        optionMaybe   : _combinators.optionMaybe,
        optional      : _combinators.optional,
        between       : _combinators.between,
        many1         : _combinators.many1,
        skipMany1     : _combinators.skipMany1,
        sepBy         : _combinators.sepBy,
        sepBy1        : _combinators.sepBy1,
        sepEndBy      : _combinators.sepEndBy,
        sepEndBy1     : _combinators.sepEndBy1,
        endBy         : _combinators.endBy,
        endBy1        : _combinators.endBy1,
        count         : _combinators.count,
        chainl        : _combinators.chainl,
        chainl1       : _combinators.chainl1,
        chainr        : _combinators.chainr,
        chainr1       : _combinators.chainr1,
        anyToken      : _combinators.anyToken,
        notFollowedBy : _combinators.notFollowedBy,
        eof           : _combinators.eof,
        reduceManyTill: _combinators.reduceManyTill,
        manyTill      : _combinators.manyTill,
        skipManyTill  : _combinators.skipManyTill
    });
};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Grass-JS
 * copyright (c) 2016 Susisu
 */



module.exports = __webpack_require__(5);


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

// NOTE: hacked together to expose an execute script tag as grass function,
//        returning a promise that resolves with stdout and the return value

const grass = __webpack_require__(3);

module.exports = (sel, input) => new Promise((resolve, reject) => {
  try {
    const { text } = document.querySelector(sel);
    let stdout = '';
    const vm = new grass.vm.VM(grass.parser.parse(sel, text), input, x => stdout += String.fromCharCode(x));
    vm.run().then(ret => {
      resolve({ stdout, return: ret });
    });
  } catch(e) {
    console.error('err', e);
    reject(`Grass interpretation failed: ${e}`);
  }
});


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Grass-JS / grass.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        vm,
        parser
    });
}

const vm     = __webpack_require__(1);
const parser = __webpack_require__(6);

end();


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Grass-JS / parser.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        ParseError,
        parse
    });
}

const lq = __webpack_require__(28)();

const vm = __webpack_require__(1);

const whiteSpace     = lq.noneOf("wWvｗＷｖ").skipMany().hidden();
const headWhiteSpace = lq.noneOf("wｗ").skipMany().hidden();

function lexeme(p) {
    return p.skip(whiteSpace);
}

const char_w = lexeme(lq.oneOf("wｗ")).label("w");
const char_W = lexeme(lq.oneOf("WＷ")).label("W");
const char_v = lexeme(lq.oneOf("vｖ")).label("v");

const app = lq.do(function* () {
    const pos  = yield lq.getPosition;
    const func = yield char_W.manyChars1();
    const arg  = yield char_w.manyChars1();
    return new vm.App(pos, func.length - 1, arg.length - 1);
}).label("application");

const abs = lq.do(function* () {
    const pos   = yield lq.getPosition;
    const arity = yield char_w.manyChars1();
    const body  = yield app.many();
    return new vm.Abs(pos, arity.length, vm.listFromArray(body));
}).label("abstraction");

const prog = lq.do(function* () {
    yield headWhiteSpace;
    const head = yield abs;
    const tail = yield char_v.and(abs.or(app.many())).many();
    yield lq.eof;
    return vm.listFromArray([head].concat(flatten(tail)));
});

function flatten(arr) {
    const arr_ = [];
    for (const e of arr) {
        if (Array.isArray(e)) {
            for (const f of e) {
                arr_.push(f);
            }
        }
        else {
            arr_.push(e);
        }
    }
    return arr_;
}

// wrapper of lq.ParseError
class ParseError extends Error {
    constructor(error) {
        super(error.toString());
        this.name  = this.constructor.name;
        this.error = error;
    }

    get pos() {
        return this.error.pos;
    }
}

function parse(name, src) {
    const res = lq.parse(prog, name, src, undefined, { tabWidth: 8 });
    if (res.success) {
        return res.value;
    }
    else {
        throw new ParseError(res.error);
    }
}

end();


/***/ }),
/* 7 */
/***/ (function(module, exports) {


/**
 * slice() reference.
 */

var slice = Array.prototype.slice;

/**
 * Expose `co`.
 */

module.exports = co['default'] = co.co = co;

/**
 * Wrap the given generator `fn` into a
 * function that returns a promise.
 * This is a separate function so that
 * every `co()` call doesn't create a new,
 * unnecessary closure.
 *
 * @param {GeneratorFunction} fn
 * @return {Function}
 * @api public
 */

co.wrap = function (fn) {
  createPromise.__generatorFunction__ = fn;
  return createPromise;
  function createPromise() {
    return co.call(this, fn.apply(this, arguments));
  }
};

/**
 * Execute the generator function or a generator
 * and return a promise.
 *
 * @param {Function} fn
 * @return {Promise}
 * @api public
 */

function co(gen) {
  var ctx = this;
  var args = slice.call(arguments, 1)

  // we wrap everything in a promise to avoid promise chaining,
  // which leads to memory leak errors.
  // see https://github.com/tj/co/issues/180
  return new Promise(function(resolve, reject) {
    if (typeof gen === 'function') gen = gen.apply(ctx, args);
    if (!gen || typeof gen.next !== 'function') return resolve(gen);

    onFulfilled();

    /**
     * @param {Mixed} res
     * @return {Promise}
     * @api private
     */

    function onFulfilled(res) {
      var ret;
      try {
        ret = gen.next(res);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }

    /**
     * @param {Error} err
     * @return {Promise}
     * @api private
     */

    function onRejected(err) {
      var ret;
      try {
        ret = gen.throw(err);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }

    /**
     * Get the next value in the generator,
     * return a promise.
     *
     * @param {Object} ret
     * @return {Promise}
     * @api private
     */

    function next(ret) {
      if (ret.done) return resolve(ret.value);
      var value = toPromise.call(ctx, ret.value);
      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '
        + 'but the following object was passed: "' + String(ret.value) + '"'));
    }
  });
}

/**
 * Convert a `yield`ed value into a promise.
 *
 * @param {Mixed} obj
 * @return {Promise}
 * @api private
 */

function toPromise(obj) {
  if (!obj) return obj;
  if (isPromise(obj)) return obj;
  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
  if ('function' == typeof obj) return thunkToPromise.call(this, obj);
  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
  if (isObject(obj)) return objectToPromise.call(this, obj);
  return obj;
}

/**
 * Convert a thunk to a promise.
 *
 * @param {Function}
 * @return {Promise}
 * @api private
 */

function thunkToPromise(fn) {
  var ctx = this;
  return new Promise(function (resolve, reject) {
    fn.call(ctx, function (err, res) {
      if (err) return reject(err);
      if (arguments.length > 2) res = slice.call(arguments, 1);
      resolve(res);
    });
  });
}

/**
 * Convert an array of "yieldables" to a promise.
 * Uses `Promise.all()` internally.
 *
 * @param {Array} obj
 * @return {Promise}
 * @api private
 */

function arrayToPromise(obj) {
  return Promise.all(obj.map(toPromise, this));
}

/**
 * Convert an object of "yieldables" to a promise.
 * Uses `Promise.all()` internally.
 *
 * @param {Object} obj
 * @return {Promise}
 * @api private
 */

function objectToPromise(obj){
  var results = new obj.constructor();
  var keys = Object.keys(obj);
  var promises = [];
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var promise = toPromise.call(this, obj[key]);
    if (promise && isPromise(promise)) defer(promise, key);
    else results[key] = obj[key];
  }
  return Promise.all(promises).then(function () {
    return results;
  });

  function defer(promise, key) {
    // predefine the key in the result
    results[key] = undefined;
    promises.push(promise.then(function (res) {
      results[key] = res;
    }));
  }
}

/**
 * Check if `obj` is a promise.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isPromise(obj) {
  return 'function' == typeof obj.then;
}

/**
 * Check if `obj` is a generator.
 *
 * @param {Mixed} obj
 * @return {Boolean}
 * @api private
 */

function isGenerator(obj) {
  return 'function' == typeof obj.next && 'function' == typeof obj.throw;
}

/**
 * Check if `obj` is a generator function.
 *
 * @param {Mixed} obj
 * @return {Boolean}
 * @api private
 */
function isGeneratorFunction(obj) {
  var constructor = obj.constructor;
  if (!constructor) return false;
  if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;
  return isGenerator(constructor.prototype);
}

/**
 * Check for plain object.
 *
 * @param {Mixed} val
 * @return {Boolean}
 * @api private
 */

function isObject(val) {
  return Object == val.constructor;
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-char
 */



module.exports = (_core, opts) => {
    if (opts === undefined) {
        opts = {};
    }

    const _prim = __webpack_require__(0)(_core);
    const _char = __webpack_require__(9)(_core, _prim);

    if (opts.sugar) {
        const _sugar = __webpack_require__(10)(_core, _char);
        _core.extendParser(_sugar);
    }

    return Object.freeze({
        string    : _char.string,
        satisfy   : _char.satisfy,
        oneOf     : _char.oneOf,
        noneOf    : _char.noneOf,
        char      : _char.char,
        anyChar   : _char.anyChar,
        space     : _char.space,
        spaces    : _char.spaces,
        newline   : _char.newline,
        tab       : _char.tab,
        upper     : _char.upper,
        lower     : _char.lower,
        letter    : _char.letter,
        digit     : _char.digit,
        alphaNum  : _char.alphaNum,
        octDigit  : _char.octDigit,
        hexDigit  : _char.hexDigit,
        manyChars : _char.manyChars,
        manyChars1: _char.manyChars1,
        regexp    : _char.regexp
    });
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-char / char.js
 */

/**
 * @module char
 */



module.exports = (_core, _prim) => {
    function end() {
        return Object.freeze({
            string,
            satisfy,
            oneOf,
            noneOf,
            char,
            anyChar,
            space,
            spaces,
            newline,
            tab,
            upper,
            lower,
            letter,
            digit,
            alphaNum,
            octDigit,
            hexDigit,
            manyChars,
            manyChars1,
            regexp
        });
    }

    const show             = _core.show;
    const ErrorMessageType = _core.ErrorMessageType;
    const ErrorMessage     = _core.ErrorMessage;
    const ParseError       = _core.ParseError;
    const uncons           = _core.uncons;
    const State            = _core.State;
    const Result           = _core.Result;
    const Parser           = _core.Parser;

    const pure       = _prim.pure;
    const bind       = _prim.bind;
    const label      = _prim.label;
    const reduceMany = _prim.reduceMany;
    const skipMany   = _prim.skipMany;

    /**
     * @function module:char.string
     * @static
     * @param {string} str
     * @returns {AbstractParser}
     */
    function string(str) {
        function eofError(pos) {
            return new ParseError(
                pos,
                [
                    new ErrorMessage(ErrorMessageType.SYSTEM_UNEXPECT, ""),
                    new ErrorMessage(ErrorMessageType.EXPECT, show(str))
                ]
            );
        }
        function expectError(pos, char) {
            return new ParseError(
                pos,
                [
                    new ErrorMessage(ErrorMessageType.SYSTEM_UNEXPECT, show(char)),
                    new ErrorMessage(ErrorMessageType.EXPECT, show(str))
                ]
            );
        }
        return new Parser(state => {
            const len = str.length;
            if (len === 0) {
                return Result.esuc(ParseError.unknown(state.pos), "", state);
            }
            const tabWidth = state.config.tabWidth;
            const unicode  = state.config.unicode;
            let rest = state.input;
            if (unicode) {
                let consumed = false;
                for (const char of str) {
                    const unconsed = uncons(rest, unicode);
                    if (unconsed.empty) {
                        return !consumed
                            ? Result.eerr(eofError(state.pos))
                            : Result.cerr(eofError(state.pos));
                    }
                    else {
                        if (char === unconsed.head) {
                            rest     = unconsed.tail;
                            consumed = true;
                        }
                        else {
                            return !consumed
                                ? Result.eerr(expectError(state.pos, unconsed.head))
                                : Result.cerr(expectError(state.pos, unconsed.head));
                        }
                    }
                }
            }
            else {
                for (let i = 0; i < len; i++) {
                    const unconsed = uncons(rest, unicode);
                    if (unconsed.empty) {
                        return i === 0
                            ? Result.eerr(eofError(state.pos))
                            : Result.cerr(eofError(state.pos));
                    }
                    else {
                        if (str[i] === unconsed.head) {
                            rest = unconsed.tail;
                        }
                        else {
                            return i === 0
                                ? Result.eerr(expectError(state.pos, unconsed.head))
                                : Result.cerr(expectError(state.pos, unconsed.head));
                        }
                    }
                }
            }
            const newPos = state.pos.addString(str, tabWidth, unicode);
            return Result.csuc(
                ParseError.unknown(newPos),
                str,
                new State(state.config, rest, newPos, state.userState)
            );
        });
    }

    /**
     * @function module:char.satisfy
     * @static
     * @param {function} test
     * @returns {AbstractParser}
     */
    function satisfy(test) {
        function systemUnexpectError(pos, str) {
            return new ParseError(
                pos,
                [new ErrorMessage(ErrorMessageType.SYSTEM_UNEXPECT, str)]
            );
        }
        return new Parser(state => {
            const unconsed = uncons(state.input, state.config.unicode);
            if (unconsed.empty) {
                return Result.eerr(systemUnexpectError(state.pos, ""));
            }
            else {
                if (test(unconsed.head, state.config)) {
                    const newPos = state.pos.addChar(unconsed.head, state.config.tabWidth);
                    return Result.csuc(
                        ParseError.unknown(newPos),
                        unconsed.head,
                        new State(state.config, unconsed.tail, newPos, state.userState)
                    );
                }
                else {
                    return Result.eerr(systemUnexpectError(state.pos, show(unconsed.head)));
                }
            }
        });
    }

    /**
     * @function module:char.oneOf
     * @static
     * @param {string} str
     * @returns {AbstractParser}
     */
    function oneOf(str) {
        const cpChars = new Set(str);
        const chars   = new Set();
        for (let i = 0; i < str.length; i++) {
            chars.add(str[i]);
        }
        return satisfy((char, config) => config.unicode ? cpChars.has(char) : chars.has(char));
    }

    /**
     * @function module:char.noneOf
     * @static
     * @param {string} str
     * @returns {AbstractParser}
     */
    function noneOf(str) {
        const cpChars = new Set(str);
        const chars   = new Set();
        for (let i = 0; i < str.length; i++) {
            chars.add(str[i]);
        }
        return satisfy((char, config) => config.unicode ? !cpChars.has(char) : !chars.has(char));
    }

    /**
     * @function module:char.char
     * @static
     * @param {string} expectChar
     * @returns {AbstractParser}
     */
    function char(expectChar) {
        return label(satisfy(char => char === expectChar), show(expectChar));
    }

    /**
     * @constant module:char.anyChar
     * @static
     * @type {AbstractParser}
     */
    const anyChar = satisfy(() => true);

    const spaceChars    = new Set(" \f\n\r\t\v");
    const upperChars    = new Set("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
    const lowerChars    = new Set("abcdefghijklmnopqrstuvwxyz");
    const letterChars   = new Set("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
    const digitChars    = new Set("0123456789");
    const alphaNumChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
    const octDigitChars = new Set("01234567");
    const hexDigitChars = new Set("0123456789ABCDEFabcdef");

    /**
     * @constant module:char.space
     * @static
     * @type {AbstractParser}
     */
    const space = label(satisfy(char => spaceChars.has(char)), "space");

    /**
     * @constant module:char.spaces
     * @static
     * @type {AbstractParser}
     */
    const spaces = label(skipMany(space), "white space");

    /**
     * @constant module:char.newline
     * @static
     * @type {AbstractParser}
     */
    const newline = label(char("\n"), "new-line");

    /**
     * @constant module:char.tab
     * @static
     * @type {AbstractParser}
     */
    const tab = label(char("\t"), "tab");

    /**
     * @constant module:char.upper
     * @static
     * @type {AbstractParser}
     */
    const upper = label(satisfy(char => upperChars.has(char)), "uppercase letter");

    /**
     * @constant module:char.lower
     * @static
     * @type {AbstractParser}
     */
    const lower = label(satisfy(char => lowerChars.has(char)), "lowercase letter");

    /**
     * @constant module:char.letter
     * @static
     * @type {AbstractParser}
     */
    const letter = label(satisfy(char => letterChars.has(char)), "letter");

    /**
     * @constant module:char.digit
     * @static
     * @type {AbstractParser}
     */
    const digit = label(satisfy(char => digitChars.has(char)), "digit");

    /**
     * @constant module:char.alphaNum
     * @static
     * @type {AbstractParser}
     */
    const alphaNum = label(satisfy(char => alphaNumChars.has(char)), "letter or digit");

    /**
     * @constant module:char.octDigit
     * @static
     * @type {AbstractParser}
     */
    const octDigit = label(satisfy(char => octDigitChars.has(char)), "octal digit");

    /**
     * @constant module:char.hexDigit
     * @static
     * @type {AbstractParser}
     */
    const hexDigit = label(satisfy(char => hexDigitChars.has(char)), "hexadecimal digit");

    /**
     * @function module:char.manyChars
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function manyChars(parser) {
        return reduceMany(parser, (accum, char) => accum + char, "");
    }

    /**
     * @function module:char.manyChars1
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function manyChars1(parser) {
        return bind(parser, head => bind(manyChars(parser), tail => pure(head + tail)));
    }

    /**
     * @function module:char.regexp
     * @static
     * @param {RegExp} re
     * @param {number} [groupId = 0]
     * @returns {AbstractParser}
     */
    function regexp(re, groupId) {
        if (groupId === undefined) {
            groupId = 0;
        }
        const flags = (re.ignoreCase ? "i" : "")
            + (re.multiline ? "m" : "")
            + (re.unicode ? "u" : "");
        const anchored = new RegExp(`^(?:${re.source})`, flags);
        const expectStr = show(re);
        return new Parser(state => {
            if (typeof state.input !== "string") {
                throw new Error("`regexp' is only applicable to string input");
            }
            const match = anchored.exec(state.input);
            if (match) {
                const str = match[0];
                const val = match[groupId];
                if (str.length === 0) {
                    return Result.esuc(
                        ParseError.unknown(state.pos),
                        val,
                        state
                    );
                }
                else {
                    const newPos = state.pos.addString(str, state.config.tabWidth, state.config.unicode);
                    return Result.csuc(
                        ParseError.unknown(newPos),
                        val,
                        new State(
                            state.config,
                            state.input.substr(str.length),
                            newPos,
                            state.userState
                        )
                    );
                }
            }
            else {
                return Result.eerr(
                    new ParseError(
                        state.pos,
                        [new ErrorMessage(ErrorMessageType.EXPECT, expectStr)]
                    )
                );
            }
        });
    }

    return end();
};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-char / sugar.js
 */

/**
 * @module sugar
 */



module.exports = (_core, _char) => {
    const manyChars  = _char.manyChars;
    const manyChars1 = _char.manyChars1;

    return Object.freeze({
        manyChars: function () {
            return manyChars(this);
        },
        manyChars1: function () {
            return manyChars1(this);
        }
    });
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-combinators / combinators.js
 */

/**
 * @module combinators
 */



module.exports = (_core, _prim) => {
    function end() {
        return Object.freeze({
            choice,
            option,
            optionMaybe,
            optional,
            between,
            many1,
            skipMany1,
            sepBy,
            sepBy1,
            sepEndBy,
            sepEndBy1,
            endBy,
            endBy1,
            count,
            chainl,
            chainl1,
            chainr,
            chainr1,
            anyToken,
            notFollowedBy,
            eof,
            reduceManyTill,
            manyTill,
            skipManyTill
        });
    }

    const show       = _core.show;
    const ParseError = _core.ParseError;
    const Result     = _core.Result;
    const Parser     = _core.Parser;

    const map        = _prim.map;
    const pure       = _prim.pure;
    const bind       = _prim.bind;
    const then       = _prim.then;
    const mzero      = _prim.mzero;
    const mplus      = _prim.mplus;
    const label      = _prim.label;
    const unexpected = _prim.unexpected;
    const tryParse   = _prim.tryParse;
    const many       = _prim.many;
    const skipMany   = _prim.skipMany;
    const tokenPrim  = _prim.tokenPrim;

    /**
     * @function module:combinators.choice
     * @static
     * @param {Array.<AbstractParser>} parsers
     * @returns {AbstractParser}
     */
    function choice(parsers) {
        return parsers.reduceRight((accum, parser) => mplus(parser, accum), mzero);
    }

    /**
     * @function module:combinators.option
     * @static
     * @param {*} val
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function option(val, parser) {
        return mplus(parser, pure(val));
    }

    /**
     * @function module:combinators.optionmaybe
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function optionMaybe(parser) {
        return mplus(
            map(parser, val => ({ empty: false, value: val })),
            map(pure(undefined), () => ({ empty: true }))
        );
    }

    /**
     * @function module:combinators.optional
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function optional(parser) {
        return mplus(then(parser, pure(undefined)), pure(undefined));
    }

    /**
     * @function module:combinators.between
     * @static
     * @param {AbstractParser} open
     * @param {AbstractParser} close
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function between(open, close, parser) {
        return then(open,
            bind(parser, val =>
                then(close,
                    pure(val)
                )
            )
        );
    }

    /**
     * @function module:combinators.many1
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function many1(parser) {
        return bind(parser, head =>
            bind(many(parser), tail =>
                pure([head].concat(tail))
            )
        );
    }

    /**
     * @function module:combinators.skipMany1
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function skipMany1(parser) {
        return then(parser, skipMany(parser));
    }

    /**
     * @function module:combinators.sepBy
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} sep
     * @returns {AbstractParser}
     */
    function sepBy(parser, sep) {
        return mplus(
            sepBy1(parser, sep),
            map(pure(undefined), () => [])
        );
    }

    /**
     * @function module:combinators.sepBy1
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} sep
     * @returns {AbstractParser}
     */
    function sepBy1(parser, sep) {
        return bind(parser, head =>
            bind(many(then(sep, parser)), tail =>
                pure([head].concat(tail))
            )
        );
    }

    /**
     * @function module:combinators.sepEndBy
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} sep
     * @returns {AbstractParser}
     */
    function sepEndBy(parser, sep) {
        return new Parser(state => {
            const accum = [];
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;
            while (true) {
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum.push(res.val);
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        accum.push(res.val);
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.csuc(ParseError.merge(currentErr, res.err), accum, currentState)
                            : Result.esuc(ParseError.merge(currentErr, res.err), accum, currentState);
                    }
                }
                const sepRes = sep.run(currentState);
                if (sepRes.success) {
                    if (sepRes.consumed) {
                        consumed = true;
                        currentState = sepRes.state;
                        currentErr = sepRes.err;
                    }
                    else {
                        currentState = sepRes.state;
                        currentErr = ParseError.merge(currentErr, sepRes.err);
                    }
                }
                else {
                    if (sepRes.consumed) {
                        return sepRes;
                    }
                    else {
                        return consumed
                            ? Result.csuc(ParseError.merge(currentErr, sepRes.err), accum, currentState)
                            : Result.esuc(ParseError.merge(currentErr, sepRes.err), accum, currentState);
                    }
                }
            }
        });
    }

    /**
     * @function module:combinators.sepEndBy1
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} sep
     * @returns {AbstractParser}
     */
    function sepEndBy1(parser, sep) {
        return bind(parser, head =>
            mplus(
                then(sep,
                    bind(sepEndBy(parser, sep), tail =>
                        pure([head].concat(tail))
                    )
                ),
                pure([head])
            )
        );
    }

    /**
     * @function module:combinators.endBy
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} sep
     * @returns {AbstractParser}
     */
    function endBy(parser, sep) {
        return many(
            bind(parser, val =>
                then(sep, pure(val))
            )
        );
    }

    /**
     * @function module:combinators.endBy1
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} sep
     * @returns {AbstractParser}
     */
    function endBy1(parser, sep) {
        return many1(
            bind(parser, val =>
                then(sep, pure(val))
            )
        );
    }

    /**
     * @function module:combinators.count
     * @static
     * @param {number} num
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function count(num, parser) {
        if (num <= 0) {
            return map(pure(undefined), () => []);
        }
        else {
            return new Parser(state => {
                const accum = [];
                let currentState = state;
                let currentErr = ParseError.unknown(state.pos);
                let consumed = false;
                for (let i = 0; i < num; i++) {
                    const res = parser.run(currentState);
                    if (res.success) {
                        if (res.consumed) {
                            consumed = true;
                            accum.push(res.val);
                            currentState = res.state;
                            currentErr = res.err;
                        }
                        else {
                            accum.push(res.val);
                            currentState = res.state;
                            currentErr = ParseError.merge(currentErr, res.err);
                        }
                    }
                    else {
                        if (res.consumed) {
                            return res;
                        }
                        else {
                            return consumed
                                ? Result.cerr(ParseError.merge(currentErr, res.err))
                                : Result.eerr(ParseError.merge(currentErr, res.err));
                        }
                    }
                }
                return consumed
                    ? Result.csuc(currentErr, accum, currentState)
                    : Result.esuc(currentErr, accum, currentState);
            });
        }
    }

    /**
     * @function module:combinators.chainl
     * @static
     * @param {AbstractParser} term
     * @param {AbstractParser} op
     * @param {*} defaultVal
     * @returns {AbstractParser}
     */
    function chainl(term, op, defaultVal) {
        return mplus(
            chainl1(term, op),
            pure(defaultVal)
        );
    }

    /**
     * @function module:combinators.chainl1
     * @static
     * @param {AbstractParser} term
     * @param {AbstractParser} op
     * @returns {AbstractParser}
     */
    function chainl1(term, op) {
        return new Parser(state => {
            let currentVal;
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;

            const headRes = term.run(currentState);
            if (headRes.success) {
                if (headRes.consumed) {
                    consumed = true;
                    currentVal = headRes.val;
                    currentState = headRes.state;
                    currentErr = ParseError.merge(currentErr, headRes.err);
                }
                else {
                    currentVal = headRes.val;
                    currentState = headRes.state;
                    currentErr = ParseError.merge(currentErr, headRes.err);
                }
            }
            else {
                return headRes.consumed
                    ? headRes
                    : Result.eerr(ParseError.merge(currentErr, headRes.err));
            }

            while (true) {
                const initState = currentState;

                const opRes = op.run(currentState);
                let operation;
                if (opRes.success) {
                    if (opRes.consumed) {
                        consumed = true;
                        operation = opRes.val;
                        currentState = opRes.state;
                        currentErr = opRes.err;
                    }
                    else {
                        operation = opRes.val;
                        currentState = opRes.state;
                        currentErr = ParseError.merge(currentErr, opRes.err);
                    }
                }
                else {
                    if (opRes.consumed) {
                        return opRes;
                    }
                    else {
                        return consumed
                            ? Result.csuc(ParseError.merge(currentErr, opRes.err), currentVal, initState)
                            : Result.esuc(ParseError.merge(currentErr, opRes.err), currentVal, initState);
                    }
                }

                const termRes = term.run(currentState);
                if (termRes.success) {
                    if (termRes.consumed) {
                        consumed = true;
                        currentVal = operation(currentVal, termRes.val);
                        currentState = termRes.state;
                        currentErr = termRes.err;
                    }
                    else {
                        currentVal = operation(currentVal, termRes.val);
                        currentState = termRes.state;
                        currentErr = ParseError.merge(currentErr, termRes.err);
                    }
                }
                else {
                    if (termRes.consumed) {
                        return termRes;
                    }
                    else {
                        if (opRes.consumed) {
                            return Result.cerr(ParseError.merge(currentErr, termRes.err));
                        }
                        else {
                            return consumed
                                ? Result.csuc(ParseError.merge(currentErr, termRes.err), currentVal, initState)
                                : Result.esuc(ParseError.merge(currentErr, termRes.err), currentVal, initState);
                        }
                    }
                }
            }
        });
    }

    /**
     * @function module:combinators.chainr
     * @static
     * @param {AbstractParser} term
     * @param {AbstractParser} op
     * @param {*} defaultVal
     * @returns {AbstractParser}
     */
    function chainr(term, op, defaultVal) {
        return mplus(
            chainr1(term, op),
            pure(defaultVal)
        );
    }

    /**
     * @function module:combinators.chainr1
     * @static
     * @param {AbstractParser} term
     * @param {AbstractParser} op
     * @returns {AbstractParser}
     */
    function chainr1(term, op) {
        return new Parser(state => {
            let resultVal;
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;

            const headRes = term.run(currentState);
            if (headRes.success) {
                if (headRes.consumed) {
                    consumed = true;
                    resultVal = headRes.val;
                    currentState = headRes.state;
                    currentErr = headRes.err;
                }
                else {
                    resultVal = headRes.val;
                    currentState = headRes.state;
                    currentErr = ParseError.merge(currentErr, headRes.err);
                }
            }
            else {
                return headRes.consumed
                    ? headRes
                    : Result.eerr(ParseError.merge(currentErr, headRes.err));
            }

            const accum = [];
            const operations = [];
            while (true) {
                const initState = currentState;

                const opRes = op.run(currentState);
                if (opRes.success) {
                    if (opRes.consumed) {
                        consumed = true;
                        operations.push(opRes.val);
                        currentState = opRes.state;
                        currentErr = opRes.err;
                    }
                    else {
                        operations.push(opRes.val);
                        currentState = opRes.state;
                        currentErr = ParseError.merge(currentErr, opRes.err);
                    }
                }
                else {
                    if (opRes.consumed) {
                        return opRes;
                    }
                    else {
                        if (accum.length > 0) {
                            let currentVal = accum[accum.length - 1];
                            for (let i = accum.length - 2; i >= 0; i--) {
                                currentVal = operations[i + 1](accum[i], currentVal);
                            }
                            resultVal = operations[0](resultVal, currentVal);
                        }
                        return consumed
                            ? Result.csuc(ParseError.merge(currentErr, opRes.err), resultVal, initState)
                            : Result.esuc(ParseError.merge(currentErr, opRes.err), resultVal, initState);
                    }
                }

                const termRes = term.run(currentState);
                if (termRes.success) {
                    if (termRes.consumed) {
                        consumed = true;
                        accum.push(termRes.val);
                        currentState = termRes.state;
                        currentErr = termRes.err;
                    }
                    else {
                        accum.push(termRes.val);
                        currentState = termRes.state;
                        currentErr = ParseError.merge(currentErr, termRes.err);
                    }
                }
                else {
                    if (termRes.consumed) {
                        return termRes;
                    }
                    else {
                        if (opRes.consumed) {
                            return Result.cerr(ParseError.merge(currentErr, termRes.err));
                        }
                        else {
                            if (accum.length > 0) {
                                let currentVal = accum[accum.length - 1];
                                for (let i = accum.length - 2; i >= 0; i--) {
                                    currentVal = operations[i + 1](accum[i], currentVal);
                                }
                                resultVal = operations[0](resultVal, currentVal);
                            }
                            return consumed
                                ? Result.csuc(ParseError.merge(currentErr, termRes.err), resultVal, initState)
                                : Result.esuc(ParseError.merge(currentErr, termRes.err), resultVal, initState);
                        }
                    }
                }
            }
        });
    }

    /**
     * @constant module:combinators.anyToken
     * @static
     * @type {AbstractParser}
     */
    const anyToken = tokenPrim(
        token => ({ empty: false, value: token }),
        show,
        pos => pos
    );

    /**
     * @function module:combinators.notFollowedBy
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function notFollowedBy(parser) {
        const modParser = new Parser(state => {
            const res = parser.run(state);
            if (res.consumed && !res.success) {
                return Result.eerr(res.err);
            }
            else if (!res.consumed && res.success) {
                return Result.csuc(res.err, res.val, res.state);
            }
            else {
                return res;
            }
        });
        return tryParse(
            mplus(
                bind(modParser, val => unexpected(show(val))),
                pure(undefined)
            )
        );
    }

    /**
     * @constant module:combinators.eof
     * @static
     * @type {AbstractParser}
     */
    const eof = label(notFollowedBy(anyToken), "end of input");

    /**
     * @function module:combinators.reduceManyTill
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} end
     * @param {function} callback
     * @param {*} initVal
     * @returns {AbstractParser}
     */
    function reduceManyTill(parser, end, callback, initVal) {
        return new Parser(state => {
            let accum = initVal;
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;
            while (true) {
                const endRes = end.run(currentState);
                if (endRes.success) {
                    if (endRes.consumed) {
                        return Result.csuc(endRes.err, accum, endRes.state);
                    }
                    else {
                        return consumed
                            ? Result.csuc(ParseError.merge(currentErr, endRes.err), accum, endRes.state)
                            : Result.esuc(ParseError.merge(currentErr, endRes.err), accum, endRes.state);
                    }
                }
                else {
                    if (endRes.consumed) {
                        return endRes;
                    }
                    else {
                        currentErr = ParseError.merge(currentErr, endRes.err);
                    }
                }

                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum = callback(accum, res.val);
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        accum = callback(accum, res.val);
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }
            }
        });
    }

    /**
     * @function module:combinators.manyTill
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} end
     * @returns {AbstractParser}
     */
    function manyTill(parser, end) {
        return new Parser(state => {
            const accum = [];
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;
            while (true) {
                const endRes = end.run(currentState);
                if (endRes.success) {
                    if (endRes.consumed) {
                        return Result.csuc(endRes.err, accum, endRes.state);
                    }
                    else {
                        return consumed
                            ? Result.csuc(ParseError.merge(currentErr, endRes.err), accum, endRes.state)
                            : Result.esuc(ParseError.merge(currentErr, endRes.err), accum, endRes.state);
                    }
                }
                else {
                    if (endRes.consumed) {
                        return endRes;
                    }
                    else {
                        currentErr = ParseError.merge(currentErr, endRes.err);
                    }
                }

                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum.push(res.val);
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        accum.push(res.val);
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }
            }
        });
    }

    /**
     * @function module:combinators.skipManyTill
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} end
     * @returns {AbstractParser}
     */
    function skipManyTill(parser, end) {
        return reduceManyTill(parser, end, accum => accum, undefined);
    }

    return end();
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-combinators / sugar.js
 */

/**
 * @module sugar
 */



module.exports = (_core, _prim, _combinators) => {
    const isParser = _core.isParser;

    const left     = _prim.left;
    const tryParse = _prim.tryParse;

    const option         = _combinators.option;
    const optionMaybe    = _combinators.optionMaybe;
    const optional       = _combinators.optional;
    const between        = _combinators.between;
    const many1          = _combinators.many1;
    const skipMany1      = _combinators.skipMany1;
    const sepBy          = _combinators.sepBy;
    const sepBy1         = _combinators.sepBy1;
    const sepEndBy       = _combinators.sepEndBy;
    const sepEndBy1      = _combinators.sepEndBy1;
    const endBy          = _combinators.endBy;
    const endBy1         = _combinators.endBy1;
    const count          = _combinators.count;
    const notFollowedBy  = _combinators.notFollowedBy;
    const reduceManyTill = _combinators.reduceManyTill;
    const manyTill       = _combinators.manyTill;
    const skipManyTill   = _combinators.skipManyTill;

    return Object.freeze({
        option: function (val) {
            return option(this, val);
        },
        optionMaybe: function () {
            return optionMaybe(this);
        },
        optional: function () {
            return optional(this);
        },
        between: function (open, close) {
            return between(open, close, this);
        },
        many1: function () {
            return many1(this);
        },
        skipMany1: function (parser) {
            return isParser(parser)
                ? left(this, skipMany1(parser))
                : skipMany1(this);
        },
        sepBy: function (sep) {
            return sepBy(this, sep);
        },
        sepBy1: function (sep) {
            return sepBy1(this, sep);
        },
        sepEndBy: function (sep) {
            return sepEndBy(this, sep);
        },
        sepEndBy1: function (sep) {
            return sepEndBy1(this, sep);
        },
        endBy: function (sep) {
            return endBy(this, sep);
        },
        endBy1: function (sep) {
            return endBy1(this, sep);
        },
        count: function (num) {
            return count(num, this);
        },
        notFollowedBy: function (parser) {
            return isParser(parser)
                ? tryParse(left(this, notFollowedBy(parser)))
                : notFollowedBy(this);
        },
        reduceManyTill: function (end, callback, initVal) {
            return reduceManyTill(this, end, callback, initVal);
        },
        manyTill: function (end) {
            return manyTill(this, end);
        },
        skipManyTill: function (parser, end) {
            return isParser(end)
                ? left(this, skipManyTill(parser, end))
                : skipManyTill(this, parser);
        }
    });
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-core
 */



module.exports = () => {
    const _utils  = __webpack_require__(18)();
    const _pos    = __webpack_require__(16)();
    const _error  = __webpack_require__(14)(_pos);
    const _stream = __webpack_require__(17)(_utils);
    const _parser = __webpack_require__(15)(_pos, _error);

    return Object.freeze({
        show        : _utils.show,
        unconsString: _utils.unconsString,

        SourcePos: _pos.SourcePos,

        ErrorMessageType  : _error.ErrorMessageType,
        ErrorMessage      : _error.ErrorMessage,
        AbstractParseError: _error.AbstractParseError,
        ParseError        : _error.ParseError,
        LazyParseError    : _error.LazyParseError,

        uncons: _stream.uncons,

        Config        : _parser.Config,
        State         : _parser.State,
        Result        : _parser.Result,
        AbstractParser: _parser.AbstractParser,
        Parser        : _parser.Parser,
        LazyParser    : _parser.LazyParser,
        lazy          : _parser.lazy,
        parse         : _parser.parse,
        isParser      : _parser.isParser,
        assertParser  : _parser.assertParser,
        extendParser  : _parser.extendParser
    });
};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-core / error.js
 */

/**
 * @module error
 */



module.exports = _pos => {
    function end() {
        return Object.freeze({
            ErrorMessageType,
            ErrorMessage,
            AbstractParseError,
            ParseError,
            LazyParseError,
            _internal: {
                cleanMessageStrings,
                joinWithCommasOr,
                joinMessageStrings
            }
        });
    }

    const SourcePos = _pos.SourcePos;

    /**
     * @constant {Object} module:error.ErrorMessageType
     * @description The `ErrorMessageType` object has string constants, each describes a type of error message:
     * - `ErrorMessageType.SYSTEM_UNEXPECT = "systemUnexpect"`
     * - `ErrorMessageType.UNEXPECT = "unexpect"`
     * - `ErrorMessageType.EXPECT = "expect"`
     * - `ErrorMessageType.MESSAGE = "mesage"`
     * @static
     */
    const ErrorMessageType = Object.freeze({
        SYSTEM_UNEXPECT: "systemUnexpect",
        UNEXPECT       : "unexpect",
        EXPECT         : "expect",
        MESSAGE        : "message"
    });

    /**
     * An instance of the `ErrorMessage` class represents a specific type error message.
     * @static
     */
    class ErrorMessage {
        /**
         * Creates a new `ErrorMessage` instance.
         * @param {string} type One of the constant of `ErrorMessageType`.
         * @param {string} msgStr Message string.
         */
        constructor(type, msgStr) {
            this._type   = type;
            this._msgStr = msgStr;
        }

        /**
         * Checks if two messages are the same.
         * @param {module:error.ErrorMessage} msgA An {@link module:error.ErrorMessage} object.
         * @param {module:error.ErrorMessage} msgB An {@link module:error.ErrorMessage} object.
         * @returns {boolean} `true` if two messages are the same.
         */
        static equal(msgA, msgB) {
            return msgA.type === msgB.type
                && msgA.msgStr === msgB.msgStr;
        }

        /**
         * Returns pretty-printed string of the error messages.
         * @param {Array.<ErrorMessage>} msgs An array of {@link module:error.ErrorMessage} objects.
         * @returns {string} Printed string.
         * @throws {Error} A message has unknown type.
         */
        static messagesToString(msgs) {
            if (msgs.length === 0) {
                return "unknown parse error";
            }
            const systemUnexpects = [];
            const unexpects       = [];
            const expects         = [];
            const defaultMessages = [];
            for (const msg of msgs) {
                switch (msg.type) {
                case ErrorMessageType.SYSTEM_UNEXPECT:
                    systemUnexpects.push(msg.msgStr);
                    break;
                case ErrorMessageType.UNEXPECT:
                    unexpects.push(msg.msgStr);
                    break;
                case ErrorMessageType.EXPECT:
                    expects.push(msg.msgStr);
                    break;
                case ErrorMessageType.MESSAGE:
                    defaultMessages.push(msg.msgStr);
                    break;
                default:
                    throw new Error("unknown message type: " + msg.type);
                }
            }
            const msgStrs = [
                unexpects.length === 0 && systemUnexpects.length !== 0
                    ? systemUnexpects[0] === ""
                        ? "unexpected end of input"
                        : "unexpected " + systemUnexpects[0]
                    : "",
                joinMessageStrings(cleanMessageStrings(unexpects), "unexpected"),
                joinMessageStrings(cleanMessageStrings(expects), "expecting"),
                joinMessageStrings(cleanMessageStrings(defaultMessages))
            ];
            return cleanMessageStrings(msgStrs).join("\n");
        }

        /**
         * Checks if two arrays describe the same error messages.
         * @param {Array.<module:error.ErrorMessage>} msgsA An array of {@link module:error.ErrorMessage} objects.
         * @param {Array.<module:error.ErrorMessage>} msgsB An array of {@link module:error.ErrorMessage} objects.
         * @returns {boolean} `true` if two arrays describe the same error messages with the same order.
         */
        static messagesEqual(msgsA, msgsB) {
            if (msgsA.length !== msgsB.length) {
                return false;
            }
            const len = msgsA.length;
            for (let i = 0; i < len; i++) {
                if (!ErrorMessage.equal(msgsA[i], msgsB[i])) {
                    return false;
                }
            }
            return true;
        }

        /**
         * @readonly
         * @type {string}
         */
        get type() {
            return this._type;
        }

        /**
         * @readonly
         * @type {string}
         */
        get msgStr() {
            return this._msgStr;
        }
    }

    /**
     * @function module:error.cleanMessageStrings
     * @description Cleans array of message strings by removing empty and duplicate elements.
     * @private
     * @static
     * @param {Array.<string>} msgStrs An array of message strings.
     * @returns {Array.<strings>} Cleaned array.
     */
    function cleanMessageStrings(msgStrs) {
        return msgStrs.filter((msgStr, i) => msgStr !== "" && msgStrs.indexOf(msgStr) === i);
    }

    /**
     * @function module:error.joinWithCommasOr
     * @description Joins strings with commas (,) and "or".
     * @private
     * @static
     * @param {Array.<string>} msgStrs An array of message strings.
     * @returns {string} Joined string.
     */
    function joinWithCommasOr(msgStrs) {
        return msgStrs.length <= 2
            ? msgStrs.join(" or ")
            : msgStrs.slice(0, msgStrs.length - 1).join(", ") + " or " + msgStrs[msgStrs.length - 1];
    }

    /**
     * @function module:error.joinMessageStrings
     * @description Joins message strings with the specified description.
     * @private
     * @static
     * @param {Array.<string>} msgStrs An array of message strings.
     * @param {string} [desc = ""] Short description of the messages.
     * @returns {string} Joined messages.
     */
    function joinMessageStrings(msgStrs, desc) {
        if (typeof desc === "undefined") {
            desc = "";
        }
        return msgStrs.length === 0
            ? ""
            : (desc === "" ? "" : desc + " ") + joinWithCommasOr(msgStrs);
    }

    /**
     * The `AbstractParseError` class is inherited by the concrete parse error classes.
     * This class is abstract and you cannot create `AbstractParseError` instance directly.
     * @static
     */
    class AbstractParseError {
        /**
         * You cannot create `AbstractParseError` instance directly.
         * @throws {Error}
         */
        constructor() {
            if (this.constructor === AbstractParseError) {
                throw new Error("cannot create AbstractParseError object");
            }
        }

        /**
         * Not implemented.
         * @readonly
         * @type {module:pos.SourcePos}
         * @throws {Error}
         */
        get pos() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @readonly
         * @type {Array.<module:error.ErrorMessage>}
         * @throws {Error}
         */
        get msgs() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @returns {string}
         * @throws {Error}
         */
        toString() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @returns {boolean}
         * @throws {Error}
         */
        isUnknown() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @param {module:pos.SourcePos} pos
         * @returns {module:error.AbstractParseError}
         * @throws {Error}
         */
        setPosition() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @param {Array.<module:error.ErrorMessage>} msgs
         * @returns {module:error.AbstractParseError}
         * @throws {Error}
         */
        setMessages() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @param {Array.<module:error.ErrorMessage>} msgs
         * @returns {module:error.AbstractParseError}
         * @throws {Error}
         */
        addMessages() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @param {string} type
         * @param {Array.<string>} msgStrs
         * @returns {module:error.AbstractParseError}
         * @throws {Error}
         */
        setSpecificTypeMessages() {
            throw new Error("not implemented");
        }
    }

    /**
     * @static
     * @extends {module:error.AbstractParseError}
     */
    class ParseError extends AbstractParseError {
        /**
         * Creates a new `ParseError` instance.
         * @param {module:pos.SourcePos} pos
         * @param {Array.<module:error.ErrorMessage>} msgs
         */
        constructor(pos, msgs) {
            super();
            this._pos  = pos;
            this._msgs = msgs;
        }

        /**
         * @param {module:pos.SourcePos} pos
         * @returns {module:error.ParseError}
         */
        static unknown(pos) {
            return new ParseError(pos, []);
        }

        /**
         * @param {module:error.AbstractParseError} errA
         * @param {module:error.AbstractParseError} errB
         * @returns {boolean}
         */
        static equal(errA, errB) {
            return SourcePos.equal(errA.pos, errB.pos)
                && ErrorMessage.messagesEqual(errA.msgs, errB.msgs);
        }

        /**
         * @param {module:error.AbstractParseError} errA
         * @param {module:error.AbstractParseError} errB
         * @returns {module:error.AbstractParseError}
         */
        static merge(errA, errB) {
            return new LazyParseError(() => {
                const cmp = SourcePos.compare(errA.pos, errB.pos);
                return errB.isUnknown() && !errA.isUnknown() ? errA
                     : errA.isUnknown() && !errB.isUnknown() ? errB
                     : cmp > 0                               ? errA
                     : cmp < 0                               ? errB
                                                             : errA.addMessages(errB.msgs);
            });
        }

        /**
         * @readonly
         * @type {module:pos.SourcePos}
         */
        get pos() {
            return this._pos;
        }

        /**
         * @readonly
         * @type {Array.<module:error.ErrorMessage>}
         */
        get msgs() {
            return this._msgs;
        }

        /**
         * @returns {string}
         */
        toString() {
            return `${this.pos}:\n${ErrorMessage.messagesToString(this.msgs)}`;
        }

        /**
         * @returns {boolean}
         */
        isUnknown() {
            return this.msgs.length === 0;
        }

        /**
         * @param {module:pos.SourcePos} pos
         * @returns {module:error.AbstractParseError}
         */
        setPosition(pos) {
            return new ParseError(pos, this.msgs);
        }

        /**
         * @param {Array.<module:error.ErrorMessage>} msgs
         * @returns {module:error.AbstractParseError}
         */
        setMessages(msgs) {
            return new ParseError(this.pos, msgs);
        }

        /**
         * @param {Array.<module:error.ErrorMessage>} msgs
         * @returns {module:error.AbstractParseError}
         */
        addMessages(msgs) {
            return new LazyParseError(() => new ParseError(this.pos, this.msgs.concat(msgs)));
        }

        /**
         * @param {string} type
         * @param {Array.<string>} msgStrs
         * @returns {module:error.AbstractParseError}
         */
        setSpecificTypeMessages(type, msgStrs) {
            return new LazyParseError(() => new ParseError(
                this.pos,
                this.msgs.filter(msg => msg.type !== type)
                    .concat(msgStrs.map(msgStr => new ErrorMessage(type, msgStr)))
            ));
        }
    }

    /**
     * @static
     * @extends {module:error.AbstractParseError}
     */
    class LazyParseError extends AbstractParseError {
        /**
         * Creates a new `LazyParseError` instance.
         * @param {function} thunk A function that returns an {@link module:error.AbstractParseError} object.
         */
        constructor(thunk) {
            super();
            this._thunk = thunk;
            this._cache = undefined;
        }

        /**
         * @returns {module:error.ParseError}
         * @throws {TypeError} Invalid thunk (not a function) found while evaluation.
         * @throws {TypeError} The final evaluation result is not a {@link module:error.ParseError} object.
         */
        eval() {
            if (this._cache) {
                return this._cache;
            }
            const lazyErrs = [];
            let err = this;
            while (err instanceof LazyParseError) {
                if (err._cache) {
                    err = err._cache;
                }
                else {
                    lazyErrs.push(err);
                    if (typeof err._thunk !== "function") {
                        throw new TypeError("thunk is not a function");
                    }
                    err = err._thunk.call(undefined);
                }
            }
            if (!(err instanceof ParseError)) {
                throw new TypeError("evaluation result is not a ParseError obejct");
            }
            for (const lazyErr of lazyErrs) {
                lazyErr._cache = err;
            }
            return err;
        }

        /**
         * @readonly
         * @type {module:pos.SourcePos}
         */
        get pos() {
            return this.eval().pos;
        }

        /**
         * @readonly
         * @type {Array.<module:error.ErrorMessage>}
         */
        get msgs() {
            return this.eval().msgs;
        }

        /**
         * @returns {string}
         */
        toString() {
            return this.eval().toString();
        }

        /**
         * @returns {boolean}
         */
        isUnknown() {
            return this.eval().isUnknown();
        }

        /**
         * @param {module:pos.SourcePos} pos
         * @returns {module:error.AbstractParseError}
         */
        setPosition(pos) {
            return new LazyParseError(() => this.eval().setPosition(pos));
        }

        /**
         * @param {Array.<module:error.ErrorMessage>} msgs
         * @returns {module:error.AbstractParseError}
         */
        setMessages(msgs) {
            return new LazyParseError(() => this.eval().setMessages(msgs));
        }

        /**
         * @param {Array.<module:error.ErrorMessage>} msgs
         * @returns {module:error.AbstractParseError}
         */
        addMessages(msgs) {
            return new LazyParseError(() => this.eval().addMessages(msgs));
        }

        /**
         * @param {string} type
         * @param {Array.<string>} msgStrs
         * @returns {module:error.AbstractParseError}
         */
        setSpecificTypeMessages(type, msgStrs) {
            return new LazyParseError(() => this.eval().setSpecificTypeMessages(type, msgStrs));
        }
    }

    return end();
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-core / parser.js
 */

/**
 * @module parser
 */



module.exports = (_pos, _error) => {
    function end() {
        return Object.freeze({
            Config,
            State,
            Result,
            AbstractParser,
            Parser,
            LazyParser,
            lazy,
            parse,
            isParser,
            assertParser,
            extendParser
        });
    }

    const SourcePos = _pos.SourcePos;

    const ParseError = _error.ParseError;

    /**
     * The `Config` class represents parser configuration.
     * @static
     */
    class Config {
        /**
         * Creates a new `Config` instance.
         * @param {Object} [opts = {}] An object containing configuration options.
         * Available configurations are listed below:
         * <table>
         * <tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr>
         * <tr><td>tabWidth</td><td>number</td><td>8</td><td>Positive integer specifying tab width.</td></tr>
         * <tr><td>unicode</td><td>boolean</td><td>false</td><td>Enables unicode features.
         * If `true`, characters are treated as code points.
         * (For instance, `"\uD83C\uDF63"` is 2 characters (code units) in non-unicode mode,
         * while it is 1 character (code point) in unicode mode.)
         * </td></tr>
         * </table>
         */
        constructor(opts) {
            if (opts === undefined) {
                opts = {};
            }
            this._tabWidth     = opts.tabWidth === undefined ? 8 : opts.tabWidth;
            this._unicode = opts.unicode === undefined ? false : opts.unicode;
        }

        /**
         * Checks if two configs are equal.
         * @param {module:parser.Config} configA
         * @param {module:parser.Config} configB
         * @returns {boolean}
         */
        static equal(configA, configB) {
            return configA.tabWidth === configB.tabWidth
                && configA.unicode === configB.unicode;
        }

        /**
         * @readonly
         * @type {number}
         */
        get tabWidth() {
            return this._tabWidth;
        }

        /**
         * @readonly
         * @type {boolean}
         */
        get unicode() {
            return this._unicode;
        }
    }

    /**
     * An instance of the `State` class describes state at some point in parsing.
     * @static
     */
    class State {
        /**
         * Creates a new `State` instance.
         * @param {module:parser.Config} config Configuration of current parsing.
         * @param {(string|Array|module:stream.IStream)} input Current input.
         * @param {module:pos.SourcePos} pos Current position.
         * @param {*} [userState = undefined] Additional user-defined state for advanced use.
         */
        constructor(config, input, pos, userState) {
            this._config    = config;
            this._input     = input;
            this._pos       = pos;
            this._userState = userState;
        }

        /**
         * Checks if two states are equal.
         * @param {module:parser.State} stateA
         * @param {module:parser.State} stateB
         * @param {(function|undefined)} [inputEqual = undefined]
         * @param {(function|undefined)} [userStateEqual = undefined]
         * @returns {boolean}
         */
        static equal(stateA, stateB, inputEqual, userStateEqual) {
            return Config.equal(stateA.config, stateB.config)
                && (inputEqual === undefined
                    ? stateA.input === stateB.input
                    : inputEqual(stateA.input, stateB.input))
                && SourcePos.equal(stateA.pos, stateB.pos)
                && (userStateEqual === undefined
                    ? stateA.userState === stateB.userState
                    : userStateEqual(stateA.userState, stateB.userState));
        }

        /**
         * @readonly
         * @type {module:parser.Config}
         */
        get config() {
            return this._config;
        }

        /**
         * @readonly
         * @type {(string|Array|module:stream.IStream)}
         */
        get input() {
            return this._input;
        }

        /**
         * @readonly
         * @type {module:pos.SourcePos}
         */
        get pos() {
            return this._pos;
        }

        /**
         * @readonly
         * @type {*}
         */
        get userState() {
            return this._userState;
        }

        /**
         * @param {module:parser.Config} config
         * @returns {module:parser.State}
         */
        setConfig(config) {
            return new State(config, this.input, this.pos, this.userState);
        }

        /**
         * @param {(string|Array|module:stream.IStream)} input
         * @returns {module:parser.State}
         */
        setInput(input) {
            return new State(this.config, input, this.pos, this.userState);
        }

        /**
         * @param {module:pos.SourcePos} pos
         * @returns {module:parser.State}
         */
        setPosition(pos) {
            return new State(this.config, this.input, pos, this.userState);
        }

        /**
         * @param {*} userState
         * @returns {module:parser.State}
         */
        setUserState(userState) {
            return new State(this.config, this.input, this.pos, userState);
        }
    }

    /**
     * The `Result` class represents a result of parsing.
     * @static
     */
    class Result {
        /**
         * Creates a new `Result` instance.
         * @param {boolean} consumed Indicates the parser consumed input or not.
         * @param {boolean} success Indicates parsing succeeded or not.
         * If `true`, `val` and `state` must be specified.
         * @param {module:error.AbstractParseError} err Parse error object.
         * @param {*} [val = undefined] Obtained value.
         * @param {(module:parser.State|undefined)} [state = undefined] Next state.
         */
        constructor(consumed, success, err, val, state) {
            this._consumed = consumed;
            this._success  = success;
            this._err      = err;
            this._val      = val;
            this._state    = state;
        }

        /**
         * Checks if two results are equal.
         * The properties `val` and `state` are compared only when both results are success.
         * @param {module:parser.Result} resA
         * @param {module:parser.Result} resB
         * @param {(function|undefined)} valEqual
         * @param {(function|undefined)} inputEqual
         * @param {(function|undefined)} userStateEqual
         * @returns {boolean}
         */
        static equal(resA, resB, valEqual, inputEqual, userStateEqual) {
            if (resA.success && resB.success) {
                return resA.consumed === resB.consumed
                    && (valEqual === undefined
                        ? resA.val === resB.val
                        : valEqual(resA.val, resB.val))
                    && State.equal(resA.state, resB.state, inputEqual, userStateEqual)
                    && ParseError.equal(resA.err, resB.err);
            }
            else {
                return resA.success === resB.success
                    && resA.consumed === resB.consumed
                    && ParseError.equal(resA.err, resB.err);
            }
        }

        /**
         * Returns a consumed success result object.
         * @param {module:error.AbstractParseError} err
         * @param {*} val
         * @param {module:parser.State} state
         * @returns {module:parser.Result}
         */
        static csuc(err, val, state) {
            return new Result(true, true, err, val, state);
        }

        /**
         * Returns a consumed failure result object.
         * @param {module:error.AbstractParseError} err
         * @returns {module:parser.Result}
         */
        static cerr(err) {
            return new Result(true, false, err);
        }

        /**
         * Returns an empty success result object.
         * @param {module:error.AbstractParseError} err
         * @param {*} val
         * @param {module:parser.State} state
         * @returns {module:parser.Result}
         */
        static esuc(err, val, state) {
            return new Result(false, true, err, val, state);
        }

        /**
         * Returns an empty failure result object.
         * @param {module:error.AbstractParseError} err
         * @returns {module:parser.Result}
         */
        static eerr(err) {
            return new Result(false, false, err);
        }

        /**
         * @readonly
         * @type {boolean}
         */
        get consumed() {
            return this._consumed;
        }

        /**
         * @readonly
         * @type {boolean}
         */
        get success() {
            return this._success;
        }

        /**
         * @readonly
         * @type {module:error.AbstractParseError}
         */
        get err() {
            return this._err;
        }

        /**
         * @readonly
         * @type {*}
         */
        get val() {
            return this._val;
        }

        /**
         * @readonly
         * @type {module:parser.State}
         */
        get state() {
            return this._state;
        }
    }

    /**
     * The `AbstractParser` class is inherited by the concrete parser classes,
     * and is used for extending all the parser classes.
     * This class is abstract and you cannot create `AbstractParser` instance directly.
     * @static
     */
    class AbstractParser {
        /**
         * You cannot create `AbstractParser` instance directly.
         * @throws {Error}
         */
        constructor() {
            if (this.constructor === AbstractParser) {
                throw new Error("cannot create AbstractParser object");
            }
        }

        /**
         * Not implemented.
         * @returns {module:parser.Result}
         * @throws {Error}
         */
        run() {
            throw new Error("not implemented");
        }

        /**
         * @param {string} name
         * @param {(string | Array | module:stream.IStream)} input
         * @param {*} [userState = undefined]
         * @param {Object} [opts = {}]
         * @returns {Object}
         */
        parse(name, input, userState, opts) {
            return parse(this, name, input, userState, opts);
        }
    }

    /**
     * The `Parser` class is just a wrapper of parser function.
     * @static
     * @extends {module:parser.AbstractParser}
     */
    class Parser extends AbstractParser {
        /**
         * Creates a new `Parser` object.
         * @param {function} func Parser function, which must take a {@link module:parser.State} object as its argument
         * and return a {@link module:parser.Result} object.
         */
        constructor(func) {
            super();
            this._func = func;
        }

        /**
         * @param {module:parser.State} state
         * @returns {module:parser.Result}
         */
        run(state) {
            return this._func.call(undefined, state);
        }
    }

    /**
     * The `LazyParser` class is a lazy version of the {@link:module.Parser} class.
     * @static
     * @extends {module:parser.AbstractParser}
     */
    class LazyParser extends AbstractParser {
        /**
         * Creates a new `LazyParser` object.
         * @param {function} thunk A function, which must return an {@link module:parser.AbstractParser} object.
         */
        constructor(thunk) {
            super();
            this._thunk = thunk;
            this._cache = undefined;
        }

        /**
         * Evaluates the thunk.
         * @returns {module:parser.Parser}
         * @throws {TypeError} Invalid thunk (not a function) found while evaluation.
         * @throws {TypeError} The final evaluation result is not a {@link module:error.ParseError} object.
         */
        eval() {
            if (this._cache) {
                return this._cache;
            }
            const lazyParsers = [];
            let parser = this;
            while (parser instanceof LazyParser) {
                if (parser._cache) {
                    parser = parser._cache;
                }
                else {
                    lazyParsers.push(parser);
                    if (typeof parser._thunk !== "function") {
                        throw new TypeError("thunk is not a function");
                    }
                    parser = parser._thunk.call(undefined);
                }
            }
            if (!(parser instanceof Parser)) {
                throw new TypeError("evaluation result is not a Parser object");
            }
            for (const lazyParser of lazyParsers) {
                lazyParser._cache = parser;
            }
            return parser;
        }

        /**
         * @param {module:parser.State} state
         * @returns {module:parser.Result}
         */
        run(state) {
            return this.eval().run(state);
        }
    }

    /**
     * @function module:parser.lazy
     * @description Shorthand for `new LazyParser()`.
     * @static
     * @param {function} thunk
     * @returns {module:parser.LazyParser}
     */
    function lazy(thunk) {
        return new LazyParser(thunk);
    }

    /**
     * @function module:parser.parse
     * @static
     * @param {module:parser.AbstractParser} parser
     * @param {string} name
     * @param {(string | Array | module:stream.IStream)} input
     * @param {*} [userState = undefined]
     * @param {Object} [opts = {}]
     * @returns {Object}
     */
    function parse(parser, name, input, userState, opts) {
        if (opts === undefined) {
            opts = {};
        }
        const state = new State(new Config(opts), input, SourcePos.init(name), userState);
        const res   = parser.run(state);
        return res.success
            ? { success: true, value: res.val }
            : { success: false, error: res.err };
    }

    /**
     * @function module:parser.isParser
     * @static
     * @param {*} val
     * @return {boolean}
     */
    function isParser(val) {
        return val instanceof AbstractParser;
    }

    /**
     * @function module:parser.assertParser
     * @static
     * @param {*} val
     * @return {undefined}
     * @throws {Error} Not a parser.
     */
    function assertParser(val) {
        if (!isParser(val)) {
            throw new Error("not a parser");
        }
    }

    /**
     * @function module:parser.extendParser
     * @static
     * @param {Object} extensions
     * @returns {undefined}
     */
    function extendParser(extensions) {
        const descs = {};
        for (const key of Object.keys(extensions)) {
            descs[key] = {
                value       : extensions[key],
                writable    : true,
                configurable: true,
                enumerable  : false
            };
        }
        Object.defineProperties(AbstractParser.prototype, descs);
    }

    return end();
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-core / pos.js
 */

/**
 * @module pos
 */



module.exports = () => {
    function end() {
        return Object.freeze({
            SourcePos
        });
    }

    /**
     * An instance of the `SourcePos` class represents a specific position in the source.
     * @static
     */
    class SourcePos {
        /**
         * Creates a new `SourcePos` instance.
         * @param {string} name Name of the source.
         * @param {number} line Line in the source.
         * @param {number} column Column in the source.
         */
        constructor(name, line, column) {
            this._name   = name;
            this._line   = line;
            this._column = column;
        }

        /**
         * Creates a new `SourcePos` instance initialized with `line = 1` and `column = 1`.
         * @param {string} name Name of the source.
         * @returns {module:pos.SourcePos} New `SourcePos` instance.
         */
        static init(name) {
            return new SourcePos(name, 1, 1);
        }

        /**
         * Checks if two `SourcePos` instances describe the same position.
         * @param {module:pos.SourcePos} posA
         * @param {module:pos.SourcePos} posB
         * @returns {boolean} `true` if two `SoucePos` instances describe the same position.
         */
        static equal(posA, posB) {
            return posA.name   === posB.name
                && posA.line   === posB.line
                && posA.column === posB.column;
        }

        /**
         * Compares two `SourcePos` instances.
         * @param {module:pos.SourcePos} posA
         * @param {module:pos.SourcePos} posB
         * @returns {number} Negative if `posA` describes a position ahead of `posB`.
         * Positive if `posA` describes a position behind `posB`.
         * Zero if `posA` and `posB` describe the same.
         */
        static compare(posA, posB) {
            return posA.name   < posB.name   ? -1
                 : posA.name   > posB.name   ? 1
                 : posA.line   < posB.line   ? -1
                 : posA.line   > posB.line   ? 1
                 : posA.column < posB.column ? -1
                 : posA.column > posB.column ? 1
                                             : 0;
        }

        /**
         * @readonly
         * @type {string}
         */
        get name() {
            return this._name;
        }

        /**
         * @readonly
         * @type {number}
         */
        get line() {
            return this._line;
        }

        /**
         * @readonly
         * @type {number}
         */
        get column() {
            return this._column;
        }

        /**
         * Returns the string representation of the position.
         * @returns {string} The string representation of the position.
         */
        toString() {
            return (this.name === "" ? "" : `"${this.name}"`)
                + `(line ${this.line}, column ${this.column})`;
        }

        /**
         * Creates a new copy of the instance with `name` set to the specified value.
         * @param {string} name
         * @returns {module:pos.SourcePos} Copy of the instance.
         */
        setName(name) {
            return new SourcePos(name, this.line, this.column);
        }

        /**
         * Creates a new copy of the instance with `line` set to the specified value.
         * @param {number} line
         * @returns {module:pos.SourcePos} Copy of the instance.
         */
        setLine(line) {
            return new SourcePos(this.name, line, this.column);
        }

        /**
         * Creates a new copy of the instance with `column` set to the specified value.
         * @param {number} column
         * @returns {module:pos.SourcePos} Copy of the instance.
         */
        setColumn(column) {
            return new SourcePos(this.name, this.line, column);
        }

        /**
         * @param {string} char
         * @param {number} tabWidth
         * @returns {module:pos.SourcePos}
         */
        addChar(char, tabWidth) {
            // For this case
            // - `if` is faster than `switch`
            // - comparing strings is faster than character codes
            if (char === "") {
                return new SourcePos(this.name, this.line, this.column);
            }
            else if (char === "\n") {
                return new SourcePos(this.name, this.line + 1, 1);
            }
            else if (char === "\t") {
                return new SourcePos(this.name, this.line, this.column + tabWidth - (this.column - 1) % tabWidth);
            }
            else {
                return new SourcePos(this.name, this.line, this.column + 1);
            }
        }

        /**
         * @param {string} str
         * @param {number} tabWidth
         * @param {boolean} unicode If `true` specified, the characters are counted in units of code points.
         * @returns {module:pos.SourcePos}
         */
        addString(str, tabWidth, unicode) {
            // For this case
            // - `switch` is faster than `if`
            // - comparing character codes is faster than strings
            let line   = this.line;
            let column = this.column;
            if (unicode) {
                for (const char of str) {
                    switch (char.charCodeAt(0)) {
                    case 10: // "\n"
                        line  += 1;
                        column = 1;
                        break;
                    case 9: // "\t"
                        column += tabWidth - (column - 1) % tabWidth;
                        break;
                    default:
                        column += 1;
                    }
                }
            }
            else {
                const len = str.length;
                for (let i = 0; i < len; i++) {
                    switch (str.charCodeAt(i)) {
                    case 10: // "\n"
                        line  += 1;
                        column = 1;
                        break;
                    case 9: // "\t"
                        column += tabWidth - (column - 1) % tabWidth;
                        break;
                    default:
                        column += 1;
                    }
                }
            }
            return new SourcePos(this.name, line, column);
        }
    }

    return end();
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-core / stream.js
 */

/**
 * @module stream
 */



module.exports = _utils => {
    function end() {
        return Object.freeze({
            uncons,
            ArrayStream
        });
    }

    const unconsString = _utils.unconsString;

    /**
     * @interface IStream
     * @description The `IStream` interface abstracts stream objects.
     * User-defined streams must implement this interface.
     * @static
     */
    /**
     * @method module:stream.IStream#uncons
     * @description Reads the stream.
     * It must return an object that satisfies these requirements:
     * <table>
     * <tr><th>Property</th><th>Type</th><th>Description</th></tr>
     * <tr><td>`empty`</td><td>boolean</td><td>Indicates the stream is empty or not.
     * If not empty, the object must have `head` and `tail` properties.</td></tr>
     * <tr><td>`head`</td><td></td><td>The head of the stream.</td></tr>
     * <tr><td>`tail`</td><td>{@link module:stream.IStream}</td><td>The tail (rest) of the stream.</td></tr>
     * </table>
     * @param {boolean} unicode If `true` specified, string-like stream should enable unicode features.
     * @returns {Object} An object that have properties describes above.
     */

    /**
     * @function module:stream.uncons
     * @description Reads input.
     * A result object should contain the following properties.
     * <table>
     * <tr><th>Property</th><th>Type</th><th>Description</th></tr>
     * <tr><td>`empty`</td><td>boolean</td><td>Indicates the input is empty or not.
     * If not empty, the object have `head` and `tail` properties.</td></tr>
     * <tr><td>`head`</td><td></td><td>The head of the input.</td></tr>
     * <tr><td>`tail`</td><td>string | Array | {@link module:stream.IStream}</td>
     * <td>The tail (rest) of the input.</td></tr>
     * </table>
     * @static
     * @param {(string|Array|module:stream.IStream)} input A string, an array,
     * or an {@link module:stream.IStream} object.
     * @param {boolean} unicode For string input, if `true` specified characters are unconsed in code point unit.
     * For string-like stream, if `true` specified it would enable unicode features
     * through {@link module:stream.IStream#uncons} method.
     * @returns {Object} An object that have properties describes above.
     * @throws {TypeError} `input` is not a string nor an array,
     * or object does not implement the {@link module:stream.IStream} interface.
     */
    function uncons(input, unicode) {
        if (typeof input === "string") {
            return unconsString(input, unicode);
        }
        else if (Array.isArray(input)) {
            return input.length === 0
                ? { empty: true }
                : { empty: false, head: input[0], tail: input.slice(1) };
        }
        else if (typeof input === "object" && input !== null) {
            if (typeof input.uncons === "function") {
                return input.uncons(unicode);
            }
            else {
                throw new TypeError("not a stream");
            }
        }
        else {
            throw new TypeError("not a stream");
        }
    }

    /**
     * The `ArrayStream` class provide more efficient stream of arrays.
     * @static
     * @implements {module:stream.IStream}
     */
    class ArrayStream {
        /**
         * Creates a new `ArrayStream` instance.
         * @param {Array} arr An array object.
         * @param {number} index Current index.
         */
        constructor(arr, index) {
            this._arr   = arr;
            this._index = index;
        }

        /**
         * @readonly
         * @type {Array}
         */
        get arr() {
            return this._arr;
        }

        /**
         * @readonly
         * @type {number}
         */
        get index() {
            return this._index;
        }

        /**
         * Returns a pair of the element at the current index and rest of the stream.
         * @param {boolean} unicode Will not be considered.
         * @returns {Object}
         */
        uncons() {
            return this._index >= this._arr.length
                ? { empty: true }
                : {
                    empty: false,
                    head : this._arr[this._index],
                    tail : new ArrayStream(this._arr, this._index + 1)
                };
        }
    }

    return end();
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-core / utils.js
 */

/**
 * @module utils
 */



module.exports = () => {
    function end() {
        return Object.freeze({
            show,
            unconsString,
            _internal: {
                escapeChar
            }
        });
    }

    const escapeMap = new Map([
        ["\\", "\\\\"],
        ["\"", "\\\""],
        ["\b", "\\b"],
        ["\f", "\\f"],
        ["\n", "\\n"],
        ["\r", "\\r"],
        ["\t", "\\t"],
        ["\v", "\\v"]
    ]);

    /**
     * @function module:utils.escapeChar
     * @description Escapes the given character `char`.
     * @private
     * @static
     * @param {string} char A character.
     * @returns {string} The escaped character.
     */
    function escapeChar(char) {
        return escapeMap.has(char) ? escapeMap.get(char) : char;
    }

    /**
     * @function module:utils.show
     * @description Pretty-printer for error messages.
     * Printing strategy is determined by the type of `value`.
     * - If `value` is a string, the string is escaped and double-quoted.
     * - If `value` is an string, each element is printed by `show()`
     * then joined with commas `,` and wrapped by braces `[ ... ]`.
     * - If `value` is an object but `value.toString` is not a function,
     * it calls `Object.prototype.toString.call(value)`.
     * - Otherwise, it calls `String(value)`
     * @static
     * @param {*} value Any value.
     * @returns {string} The printed string.
     */
    function show(value) {
        if (typeof value === "string") {
            if (value.length === 1) {
                return `"${escapeChar(value)}"`;
            }
            else {
                return `"${value.replace(/[\u0000-\u001F\\\"]/g, escapeChar)}"`;
            }
        }
        else if (Array.isArray(value)) {
            return `[${value.map(show).join(", ")}]`;
        }
        else if (typeof value === "object" && value !== null && typeof value.toString !== "function") {
            return Object.prototype.toString.call(value);
        }
        else {
            return String(value);
        }
    }

    /**
     * @function module:utils.unconsString
     * @description Reads string.
     * This is a specialized version of {@module:stream.uncons} for string.
     * A result object contains the following properties.
     * <table>
     * <tr><th>Property</th><th>Type</th><th>Description</th></tr>
     * <tr><td>`empty`</td><td>boolean</td><td>Indicates the string is empty or not.
     * If not empty, the object have `head` and `tail` properties.</td></tr>
     * <tr><td>`head`</td><td></td><td>The head of the string.</td></tr>
     * <tr><td>`tail`</td><td>string</td>
     * <td>The tail (rest) of the string.</td></tr>
     * </table>
     * @static
     * @param {string} str A string.
     * @param {boolean} unicode If `true` specified characters are unconsed in code point unit.
     * @returns {Object} An object that have properties describes above.
     */
    function unconsString(str, unicode) {
        const len = str.length;
        if (unicode) {
            if (len === 0) {
                return { empty: true };
            }
            else if (len === 1) {
                return { empty: false, head: str[0], tail: str.substr(1) };
            }
            else {
                const first = str.charCodeAt(0);
                if (first < 0xD800 || 0xDBFF < first) {
                    return { empty: false, head: str[0], tail: str.substr(1) };
                }
                const second = str.charCodeAt(1);
                if (second < 0xDC00 || 0xDFFF < second) {
                    return { empty: false, head: str[0], tail: str.substr(1) };
                }
                return { empty: false, head: String.fromCharCode(first, second), tail: str.substr(2) };
            }
        }
        else {
            return len === 0
                ? { empty: true }
                : { empty: false, head: str[0], tail: str.substr(1) };
        }
    }

    return end();
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-expr
 */



module.exports = _core => {
    const _prim        = __webpack_require__(0)(_core);
    const _combinators = __webpack_require__(2)(_core);
    const _expr        = __webpack_require__(20)(_core, _prim, _combinators);

    return Object.freeze({
        OperatorType         : _expr.OperatorType,
        OperatorAssoc        : _expr.OperatorAssoc,
        Operator             : _expr.Operator,
        buildExpressionParser: _expr.buildExpressionParser
    });
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-expr / expr.js
 */

/**
 * @module expr
 */



module.exports = (_core, _prim, _combinators) => {
    function end() {
        return Object.freeze({
            OperatorType,
            OperatorAssoc,
            Operator,
            buildExpressionParser
        });
    }

    const ParseError = _core.ParseError;
    const Result     = _core.Result;
    const Parser     = _core.Parser;

    const pure     = _prim.pure;
    const bind     = _prim.bind;
    const then     = _prim.then;
    const fail     = _prim.fail;
    const mplus    = _prim.mplus;
    const label    = _prim.label;
    const tryParse = _prim.tryParse;

    const choice = _combinators.choice;

    /**
     * @constant {Object} module:expr.OperatorType
     * @description The `OperatorType` object has string constants describing operator types:
     * - `OperatorType.INFIX = "infix"`
     * - `OperatorType.PREFIX = "prefix"`
     * - `OperatorType.POSTFIX = "postifx"`
     * @static
     */
    const OperatorType = Object.freeze({
        INFIX  : "infix",
        PREFIX : "prefix",
        POSTFIX: "postfix"
    });

    /**
     * @constant {Object} module:expr.OperatorAssoc
     * @description The `OperatorAssoc` object has string constants describing operator associativities:
     * - `OperatorAssoc.NONE = "none"`
     * - `OperatorAssoc.LEFT = "left"`
     * - `OperatorAssoc.RIGHT = "right"`
     * @static
     */
    const OperatorAssoc = Object.freeze({
        NONE : "none",
        LEFT : "left",
        RIGHT: "right"
    });

    /**
     * @static
     */
    class Operator {
        /**
         * @param {string} type
         * @param {AbstractParser} parser
         * @param {(string|undefined)} [assoc=undefined]
         */
        constructor(type, parser, assoc) {
            this._type   = type;
            this._parser = parser;
            this._assoc  = assoc;
        }

        /**
         * @readonly
         * @type {string}
         */
        get type() {
            return this._type;
        }

        /**
         * @readonly
         * @type {AbstractParser}
         */
        get parser() {
            return this._parser;
        }

        /**
         * @readonly
         * @type {(string|undefined)}
         */
        get assoc() {
            return this._assoc;
        }
    }

    /**
     * @private
     * @param {AbstractParser} term
     * @param {Array.<Operator>} ops
     * @returns {AbstractParser}
     */
    function makeParser(term, ops) {
        // collect operators
        const nonAssoc   = [];
        const leftAssoc  = [];
        const rightAssoc = [];
        const prefix     = [];
        const postfix    = [];
        for (const op of ops) {
            switch (op.type) {
            case OperatorType.INFIX:
                switch (op.assoc) {
                case OperatorAssoc.NONE:
                    nonAssoc.push(op.parser);
                    break;
                case OperatorAssoc.LEFT:
                    leftAssoc.push(op.parser);
                    break;
                case OperatorAssoc.RIGHT:
                    rightAssoc.push(op.parser);
                    break;
                default:
                    throw new Error(`unknown operator associativity: ${op.assoc}`);
                }
                break;
            case OperatorType.PREFIX:
                prefix.push(op.parser);
                break;
            case OperatorType.POSTFIX:
                postfix.push(op.parser);
                break;
            default:
                throw new Error(`unknown operator type: ${op.type}`);
            }
        }

        // create operator parsers
        const nassocOp  = choice(nonAssoc);
        const lassocOp  = choice(leftAssoc);
        const rassocOp  = choice(rightAssoc);
        const prefixOp  = label(choice(prefix), "");
        const postfixOp = label(choice(postfix), "");

        // warn ambiguity (always eerr)
        function ambiguous(assoc, parser) {
            return tryParse(
                then(parser, fail(`ambiguous use of a ${assoc} associative operator`))
            );
        }

        const ambiguousNon   = ambiguous("non", nassocOp);
        const ambiguousLeft  = ambiguous("left", lassocOp);
        const ambiguousRight = ambiguous("right", rassocOp);

        // identity
        function id(x) {
            return x;
        }

        // unary operators
        const prefixP  = mplus(prefixOp, pure(id));
        const postfixP = mplus(postfixOp, pure(id));

        // term parser
        const termP = bind(prefixP, pre =>
            bind(term, val =>
                bind(postfixP, post =>
                    pure(post(pre(val)))
                )
            )
        );

        // right assoc binary operator
        function rassocP(x) {
            return mplus(
                bind(rassocOp, f =>
                    bind(bind(termP, rassocP1), y =>
                        pure(f(x, y))
                    )
                ),
                mplus(ambiguousLeft, ambiguousNon)
            );
        }

        function rassocP1(x) {
            return new Parser(state => {
                const vals = [];
                const operations = [];
                let currentState = state;
                let currentErr = ParseError.unknown(state.pos);
                let consumed = false;
                while (true) {
                    const initState = currentState;

                    const opRes = rassocOp.run(currentState);
                    if (opRes.success) {
                        if (opRes.consumed) {
                            consumed = true;
                            operations.push(opRes.val);
                            currentState = opRes.state;
                            currentErr = opRes.err;
                        }
                        else {
                            operations.push(opRes.val);
                            currentState = opRes.state;
                            currentErr = ParseError.merge(currentErr, opRes.err);
                        }
                    }
                    else {
                        if (opRes.consumed) {
                            return opRes;
                        }
                        else {
                            const ambRes = mplus(ambiguousLeft, ambiguousNon).run(initState); // always eerr
                            const err = ParseError.merge(ParseError.merge(currentErr, opRes.err), ambRes.err);
                            let resVal = x;
                            if (vals.length > 0) {
                                let currentVal = vals[vals.length - 1];
                                for (let i = vals.length - 2; i >= 0; i -= 1) {
                                    currentVal = operations[i + 1](vals[i], currentVal);
                                }
                                resVal = operations[0](resVal, currentVal);
                            }
                            return consumed
                                ? Result.csuc(err, resVal, initState)
                                : Result.esuc(err, resVal, initState);
                        }
                    }

                    const termRes = termP.run(currentState);
                    if (termRes.success) {
                        if (termRes.consumed) {
                            consumed = true;
                            vals.push(termRes.val);
                            currentState = termRes.state;
                            currentErr = termRes.err;
                        }
                        else {
                            vals.push(termRes.val);
                            currentState = termRes.state;
                            currentErr = ParseError.merge(currentErr, termRes.err);
                        }
                    }
                    else {
                        if (termRes.consumed) {
                            return termRes;
                        }
                        else {
                            if (opRes.consumed) {
                                return Result.cerr(ParseError.merge(currentErr, termRes.err));
                            }
                            else {
                                const ambRes = mplus(ambiguousLeft, ambiguousNon).run(initState); // always eerr
                                const err = ParseError.merge(ParseError.merge(currentErr, termRes.err), ambRes.err);
                                let resVal = x;
                                if (vals.length > 0) {
                                    let currentVal = vals[vals.length - 1];
                                    for (let i = vals.length - 2; i >= 0; i -= 1) {
                                        currentVal = operations[i + 1](vals[i], currentVal);
                                    }
                                    resVal = operations[0](resVal, currentVal);
                                }
                                return consumed
                                    ? Result.csuc(err, resVal, initState)
                                    : Result.esuc(err, resVal, initState);
                            }
                        }
                    }
                }
            });
        }

        // left assoc binary operator
        function lassocP(x) {
            return mplus(
                bind(lassocOp, f =>
                    bind(termP, y =>
                        lassocP1(f(x, y))
                    )
                ),
                mplus(ambiguousRight, ambiguousNon)
            );
        }

        function lassocP1(x) {
            return new Parser(state => {
                let currentVal = x;
                let currentOperation;
                let currentState = state;
                let currentErr = ParseError.unknown(state.pos);
                let consumed = false;
                while (true) {
                    const initState = currentState;

                    const opRes = lassocOp.run(currentState);
                    if (opRes.success) {
                        if (opRes.consumed) {
                            consumed = true;
                            currentOperation = opRes.val;
                            currentState = opRes.state;
                            currentErr = opRes.err;
                        }
                        else {
                            currentOperation = opRes.val;
                            currentState = opRes.state;
                            currentErr = ParseError.merge(currentErr, opRes.err);
                        }
                    }
                    else {
                        if (opRes.consumed) {
                            return opRes;
                        }
                        else {
                            const ambRes = mplus(ambiguousRight, ambiguousNon).run(initState); // always eerr
                            const err = ParseError.merge(ParseError.merge(currentErr, opRes.err), ambRes.err);
                            return consumed
                                ? Result.csuc(err, currentVal, initState)
                                : Result.esuc(err, currentVal, initState);
                        }
                    }

                    const termRes = termP.run(currentState);
                    if (termRes.success) {
                        if (termRes.consumed) {
                            consumed = true;
                            currentVal = currentOperation(currentVal, termRes.val);
                            currentState = termRes.state;
                            currentErr = termRes.err;
                        }
                        else {
                            currentVal = currentOperation(currentVal, termRes.val);
                            currentState = termRes.state;
                            currentErr = ParseError.merge(currentErr, termRes.err);
                        }
                    }
                    else {
                        if (termRes.consumed) {
                            return termRes;
                        }
                        else {
                            if (opRes.consumed) {
                                return Result.cerr(ParseError.merge(currentErr, termRes.err));
                            }
                            else {
                                const ambRes = mplus(ambiguousRight, ambiguousNon).run(initState); // always eerr
                                const err = ParseError.merge(ParseError.merge(currentErr, termRes.err), ambRes.err);
                                return consumed
                                    ? Result.csuc(err, currentVal, initState)
                                    : Result.esuc(err, currentVal, initState);
                            }
                        }
                    }
                }
            });
        }

        // non assoc binary operator
        function nassocP(x) {
            return bind(nassocOp, f =>
                bind(termP, y =>
                    mplus(
                        mplus(mplus(ambiguousRight, ambiguousLeft), ambiguousNon),
                        pure(f(x, y))
                    )
                )
            );
        }

        return bind(termP, x =>
            label(
                mplus(
                    mplus(mplus(rassocP(x), lassocP(x)), nassocP(x)),
                    pure(x)
                ),
                "operator"
            )
        );
    }

    /**
     * @function module:expr.buildExpressionParser
     * @static
     * @param {Array.<Array.<Operator>>} opTable
     * @param {AbstractParser} atom
     * @returns {AbstractParser}
     */
    function buildExpressionParser(opTable, atom) {
        return opTable.reduce(makeParser, atom);
    }

    return end();
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-monad
 */



module.exports = (_core, opts) => {
    if (opts === undefined) {
        opts = {};
    }

    const _prim  = __webpack_require__(0)(_core);
    const _monad = __webpack_require__(22)(_core, _prim);

    if (opts.sugar) {
        const _sugar = __webpack_require__(23)(_core, _monad);
        _core.extendParser(_sugar);
    }

    return Object.freeze({
        forever    : _monad.forever,
        discard    : _monad.discard,
        void       : _monad.discard,
        join       : _monad.join,
        when       : _monad.when,
        unless     : _monad.unless,
        liftM      : _monad.liftM,
        liftM2     : _monad.liftM2,
        liftM3     : _monad.liftM3,
        liftM4     : _monad.liftM4,
        liftM5     : _monad.liftM5,
        ltor       : _monad.ltor,
        rtol       : _monad.rtol,
        sequence   : _monad.sequence,
        sequence_  : _monad.sequence_,
        mapM       : _monad.mapM,
        mapM_      : _monad.mapM_,
        forM       : _monad.forM,
        forM_      : _monad.forM_,
        filterM    : _monad.filterM,
        zipWithM   : _monad.zipWithM,
        zipWithM_  : _monad.zipWithM_,
        foldM      : _monad.foldM,
        foldM_     : _monad.foldM_,
        replicateM : _monad.replicateM,
        replicateM_: _monad.replicateM_,
        guard      : _monad.guard,
        msum       : _monad.msum,
        mfilter    : _monad.mfilter
    });
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-monad / monad.js
 */

/**
 * @module monad
 */



module.exports = (_core, _prim) => {
    function end() {
        return Object.freeze({
            forever,
            discard,
            join,
            when,
            unless,
            liftM,
            liftM2,
            liftM3,
            liftM4,
            liftM5,
            ltor,
            rtol,
            sequence,
            sequence_,
            mapM,
            mapM_,
            forM,
            forM_,
            filterM,
            zipWithM,
            zipWithM_,
            foldM,
            foldM_,
            replicateM,
            replicateM_,
            guard,
            msum,
            mfilter,
            _internal: {
                zipWith
            }
        });
    }

    const ParseError = _core.ParseError;
    const Result     = _core.Result;
    const Parser     = _core.Parser;

    const map      = _prim.map;
    const pure     = _prim.pure;
    const bind     = _prim.bind;
    const then     = _prim.then;
    const tailRecM = _prim.tailRecM;
    const mzero    = _prim.mzero;
    const mplus    = _prim.mplus;

    /**
     * @function module:monad.forever
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function forever(parser) {
        return tailRecM(
            undefined,
            () => map(parser, () => ({ done: false, value: undefined }))
        );
    }

    /**
     * @function module:monad.discard
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function discard(parser) {
        return map(parser, () => undefined);
    }

    /**
     * @function module:monad.join
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function join(parser) {
        return bind(parser, val => val);
    }

    /**
     * @function module:monad.when
     * @static
     * @param {boolean} cond
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function when(cond, parser) {
        return cond ? parser : pure(undefined);
    }

    /**
     * @function module:monad.unless
     * @static
     * @param {boolean} cond
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function unless(cond, parser) {
        return cond ? pure(undefined) : parser;
    }

    /**
     * @function module:monad.liftM
     * @static
     * @param {function} func
     * @returns {function}
     */
    function liftM(func) {
        return parser => bind(parser, val => pure(func(val)));
    }

    /**
     * @function module:monad.liftM2
     * @static
     * @param {function} func
     * @returns {function}
     */
    function liftM2(func) {
        return (parserA, parserB) =>
            bind(parserA, valA =>
                bind(parserB, valB =>
                    pure(func(valA, valB))
                )
            );
    }

    /**
     * @function module:monad.liftM3
     * @static
     * @param {function} func
     * @returns {function}
     */
    function liftM3(func) {
        return (parserA, parserB, parserC) =>
            bind(parserA, valA =>
                bind(parserB, valB =>
                    bind(parserC, valC =>
                        pure(func(valA, valB, valC))
                    )
                )
            );
    }

    /**
     * @function module:monad.liftM4
     * @static
     * @param {function} func
     * @returns {function}
     */
    function liftM4(func) {
        return (parserA, parserB, parserC, parserD) =>
            bind(parserA, valA =>
                bind(parserB, valB =>
                    bind(parserC, valC =>
                        bind(parserD, valD =>
                            pure(func(valA, valB, valC, valD))
                        )
                    )
                )
            );
    }

    /**
     * @function module:monad.liftM5
     * @static
     * @param {function} func
     * @returns {function}
     */
    function liftM5(func) {
        return (parserA, parserB, parserC, parserD, parserE) =>
            bind(parserA, valA =>
                bind(parserB, valB =>
                    bind(parserC, valC =>
                        bind(parserD, valD =>
                            bind(parserE, valE =>
                                pure(func(valA, valB, valC, valD, valE))
                            )
                        )
                    )
                )
            );
    }

    /**
     * @function module:monad.ltor
     * @static
     * @param {function} funcA
     * @param {function} funcB
     * @returns {function}
     */
    function ltor(funcA, funcB) {
        return val => bind(funcA(val), funcB);
    }

    /**
     * @function module:monad.rtol
     * @static
     * @param {function} funcA
     * @param {function} funcB
     * @returns {function}
     */
    function rtol(funcA, funcB) {
        return val => bind(funcB(val), funcA);
    }

    /**
     * @function module:monad.sequence
     * @static
     * @param {Array.<AbstractParser>} parsers
     * @returns {AbstractParser}
     */
    function sequence(parsers) {
        return new Parser(state => {
            const accum = [];
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;
            for (const parser of parsers) {
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum.push(res.val);
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        accum.push(res.val);
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }
            }
            return consumed
                ? Result.csuc(currentErr, accum, currentState)
                : Result.esuc(currentErr, accum, currentState);
        });
    }

    /**
     * @function module:monad.sequence
     * @static
     * @param {Array.<AbstractParser>} parsers
     * @returns {AbstractParser}
     */
    function sequence_(parsers) {
        return parsers.reduceRight((accum, parser) => then(parser, accum), pure(undefined));
    }

    /**
     * @function module:monad.mapM
     * @static
     * @param {function} func
     * @param {Array} arr
     * @returns {AbstractParser}
     */
    function mapM(func, arr) {
        return sequence(arr.map(elem => func(elem)));
    }

    /**
     * @function module:monad.mapM_
     * @static
     * @param {function} func
     * @param {Array} arr
     * @returns {AbstractParser}
     */
    function mapM_(func, arr) {
        return sequence_(arr.map(elem => func(elem)));
    }

    /**
     * @function module:monad.forM
     * @static
     * @param {Array} arr
     * @param {function} func
     * @returns {AbstractParser}
     */
    function forM(arr, func) {
        return mapM(func, arr);
    }

    /**
     * @function module:monad.forM_
     * @static
     * @param {Array} arr
     * @param {function} func
     * @returns {AbstractParser}
     */
    function forM_(arr, func) {
        return mapM_(func, arr);
    }

    /**
     * @function module:monad.filterM
     * @static
     * @param {function} test
     * @param {Array} arr
     * @returns {AbstractParser}
     */
    function filterM(test, arr) {
        return new Parser(state => {
            const accum = [];
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;
            for (const elem of arr) {
                const parser = test(elem);
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        if (res.val) {
                            accum.push(elem);
                        }
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        if (res.val) {
                            accum.push(elem);
                        }
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }
            }
            return consumed
                ? Result.csuc(currentErr, accum, currentState)
                : Result.esuc(currentErr, accum, currentState);
        });
    }

    /**
     * @function module:monad.zipWith
     * @private
     * @static
     * @param {function} func
     * @param {Array} arrA
     * @param {Array} arrB
     * @returns {*}
     */
    function zipWith(func, arrA, arrB) {
        const res = [];
        const len = Math.min(arrA.length, arrB.length);
        for (let i = 0; i < len; i++) {
            res.push(func(arrA[i], arrB[i]));
        }
        return res;
    }

    /**
     * @function module:monad.zipWithM
     * @static
     * @param {function} func
     * @param {Array} arrA
     * @param {Array} arrB
     * @returns {AbstractParser}
     */
    function zipWithM(func, arrA, arrB) {
        return sequence(zipWith(func, arrA, arrB));
    }

    /**
     * @function module:monad.zipWithM_
     * @static
     * @param {function} func
     * @param {Array} arrA
     * @param {Array} arrB
     * @returns {AbstractParser}
     */
    function zipWithM_(func, arrA, arrB) {
        return sequence_(zipWith(func, arrA, arrB));
    }

    /**
     * @function module:monad.foldM
     * @static
     * @param {function} func
     * @param {*} initVal
     * @param {Array} arr
     * @returns {AbstractParser}
     */
    function foldM(func, initVal, arr) {
        return new Parser(state => {
            let accum = initVal;
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;
            for (const elem of arr) {
                const parser = func(accum, elem);
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum = res.val;
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        accum = res.val;
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }
            }
            return consumed
                ? Result.csuc(currentErr, accum, currentState)
                : Result.esuc(currentErr, accum, currentState);
        });
    }

    /**
     * @function module:monad.foldM_
     * @static
     * @param {function} func
     * @param {*} initVal
     * @param {Array} arr
     * @returns {AbstractParser}
     */
    function foldM_(func, initVal, arr) {
        return then(foldM(func, initVal, arr), pure(undefined));
    }

    /**
     * @function module:monad.replicateM
     * @static
     * @param {number} num
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function replicateM(num, parser) {
        return sequence(new Array(num).fill(parser));
    }

    /**
     * @function module:monad.replicateM_
     * @static
     * @param {number} num
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function replicateM_(num, parser) {
        return sequence_(new Array(num).fill(parser));
    }

    /**
     * @function module:monad.guard
     * @static
     * @param {boolean} cond
     * @returns {AbstractParser}
     */
    function guard(cond) {
        return cond ? pure(undefined) : mzero;
    }

    /**
     * @function module:monad.msum
     * @static
     * @param {Array.<AbstractParser>} parsers
     * @returns {AbstractParser}
     */
    function msum(parsers) {
        return parsers.reduceRight((accum, parser) => mplus(parser, accum), mzero);
    }

    /**
     * @function module:monad.mfilter
     * @static
     * @param {function} test
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function mfilter(test, parser) {
        return bind(parser, val => test(val) ? pure(val) : mzero);
    }

    return end();
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-monad / sugar.js
 */

/**
 * @module sugar
 */



module.exports = (_core, _monad) => {
    const forever = _monad.forever;
    const discard = _monad.discard;
    const join    = _monad.join;
    const when    = _monad.when;
    const unless  = _monad.unless;
    const mfilter = _monad.mfilter;

    return Object.freeze({
        forever: function () {
            return forever(this);
        },
        discard: function () {
            return discard(this);
        },
        void: function () {
            return discard(this);
        },
        join: function () {
            return join(this);
        },
        when: function (cond) {
            return when(cond, this);
        },
        unless: function (cond) {
            return unless(cond, this);
        },
        filter: function (test) {
            return mfilter(test, this);
        }
    });
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-prim / prim.js
 */

/**
 * @module prim
 */



module.exports = _core => {
    function end() {
        return Object.freeze({
            map,
            fmap,
            pure,
            ap,
            left,
            right,
            bind,
            then,
            fail,
            tailRecM,
            ftailRecM,
            mzero,
            mplus,
            label,
            labels,
            hidden,
            unexpected,
            tryParse,
            lookAhead,
            reduceMany,
            many,
            skipMany,
            tokens,
            token,
            tokenPrim,
            getParserState,
            setParserState,
            updateParserState,
            getConfig,
            setConfig,
            getInput,
            setInput,
            getPosition,
            setPosition,
            getState,
            setState
        });
    }

    const ErrorMessageType = _core.ErrorMessageType;
    const ErrorMessage     = _core.ErrorMessage;
    const ParseError       = _core.ParseError;
    const LazyParseError   = _core.LazyParseError;
    const uncons           = _core.uncons;
    const State            = _core.State;
    const Result           = _core.Result;
    const Parser           = _core.Parser;

    /**
     * @function module:prim.map
     * @static
     * @param {AbstractParser} parser
     * @param {function} func
     * @returns {AbstractParser}
     */
    function map(parser, func) {
        return new Parser(state => {
            const res = parser.run(state);
            return res.success
                ? new Result(res.consumed, true, res.err, func(res.val), res.state)
                : res;
        });
    }

    /**
     * @function module:prim.fmap
     * @static
     * @param {function} func
     * @returns {function}
     */
    function fmap(func) {
        return parser => map(parser, func);
    }

    /**
     * @function module:prim.pure
     * @static
     * @param {*} val
     * @returns {AbstractParser}
     */
    function pure(val) {
        return new Parser(state => Result.esuc(ParseError.unknown(state.pos), val, state));
    }

    /**
     * @function module:prim.ap
     * @static
     * @param {AbstractParser} parserA
     * @param {AbstractParser} parserB
     * @returns {AbstractParser}
     */
    function ap(parserA, parserB) {
        return new Parser(state => {
            const resA = parserA.run(state);
            if (resA.success) {
                const func = resA.val;
                const resB = parserB.run(resA.state);
                if (resB.success) {
                    return new Result(
                        resA.consumed || resB.consumed,
                        true,
                        resB.consumed ? resB.err : ParseError.merge(resA.err, resB.err),
                        func(resB.val),
                        resB.state
                    );
                }
                else {
                    return new Result(
                        resA.consumed || resB.consumed,
                        false,
                        resB.consumed ? resB.err : ParseError.merge(resA.err, resB.err)
                    );
                }
            }
            else {
                return resA;
            }
        });
    }

    /**
     * @function module:prim.left
     * @static
     * @param {AbstractParser} parserA
     * @param {AbstractParser} parserB
     * @returns {AbstractParser}
     */
    function left(parserA, parserB) {
        return new Parser(state => {
            const resA = parserA.run(state);
            if (resA.success) {
                const resB = parserB.run(resA.state);
                if (resB.success) {
                    return new Result(
                        resA.consumed || resB.consumed,
                        true,
                        resB.consumed ? resB.err : ParseError.merge(resA.err, resB.err),
                        resA.val,
                        resB.state
                    );
                }
                else {
                    return new Result(
                        resA.consumed || resB.consumed,
                        false,
                        resB.consumed ? resB.err : ParseError.merge(resA.err, resB.err)
                    );
                }
            }
            else {
                return resA;
            }
        });
    }

    /**
     * @function module:prim.right
     * @static
     * @param {AbstractParser} parserA
     * @param {AbstractParser} parserB
     * @returns {AbstractParser}
     */
    function right(parserA, parserB) {
        return new Parser(state => {
            const resA = parserA.run(state);
            if (resA.success) {
                const resB = parserB.run(resA.state);
                if (resB.success) {
                    return new Result(
                        resA.consumed || resB.consumed,
                        true,
                        resB.consumed ? resB.err : ParseError.merge(resA.err, resB.err),
                        resB.val,
                        resB.state
                    );
                }
                else {
                    return new Result(
                        resA.consumed || resB.consumed,
                        false,
                        resB.consumed ? resB.err : ParseError.merge(resA.err, resB.err)
                    );
                }
            }
            else {
                return resA;
            }
        });
    }

    /**
     * @function module:prim.bind
     * @static
     * @param {AbstractParser} parser
     * @param {function} func
     * @returns {AbstractParser}
     */
    function bind(parser, func) {
        return new Parser(state => {
            const resA = parser.run(state);
            if (resA.success) {
                const parserB = func(resA.val);
                const resB = parserB.run(resA.state);
                return resB.consumed
                    ? resB
                    : new Result(
                        resA.consumed,
                        resB.success,
                        ParseError.merge(resA.err, resB.err),
                        resB.val,
                        resB.state
                    );
            }
            else {
                return resA;
            }
        });
    }

    /**
     * @function module:prim.then
     * @static
     * @param {AbstractParser} parserA
     * @param {AbstractParser} parserB
     * @returns {AbstracParser}
     */
    function then(parserA, parserB) {
        return new Parser(state => {
            const resA = parserA.run(state);
            if (resA.success) {
                const resB = parserB.run(resA.state);
                return resB.consumed
                    ? resB
                    : new Result(
                        resA.consumed,
                        resB.success,
                        ParseError.merge(resA.err, resB.err),
                        resB.val,
                        resB.state
                    );
            }
            else {
                return resA;
            }
        });
    }

    /**
     * @function module:prim.fail
     * @static
     * @param {string} msgStr
     * @returns {AbstractParser}
     */
    function fail(msgStr) {
        return new Parser(state => Result.eerr(
            new ParseError(state.pos, [new ErrorMessage(ErrorMessageType.MESSAGE, msgStr)])
        ));
    }

    /**
     * @function module:prim.tailRecM
     * @static
     * @param {*} initVal
     * @param {function} func
     * @returns {AbstractParser}
     */
    function tailRecM(initVal, func) {
        return new Parser(state => {
            let consumed = false;
            let currentVal = initVal;
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            while (true) {
                const parser = func(currentVal);
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        if (res.val.done) {
                            return Result.csuc(res.err, res.val.value, res.state);
                        }
                        else {
                            consumed = true;
                            currentVal = res.val.value;
                            currentState = res.state;
                            currentErr = res.err;
                        }
                    }
                    else {
                        if (res.val.done) {
                            return consumed
                                ? Result.csuc(ParseError.merge(currentErr, res.err), res.val.value, res.state)
                                : Result.esuc(ParseError.merge(currentErr, res.err), res.val.value, res.state);
                        }
                        else {
                            currentVal = res.val.value;
                            currentState = res.state;
                            currentErr = ParseError.merge(currentErr, res.err);
                        }
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }
            }
        });
    }

    /**
     * @function module:prim.ftailRecM
     * @static
     * @param {function} func
     * @returns {function}
     */
    function ftailRecM(func) {
        return initVal => tailRecM(initVal, func);
    }

    /**
     * @constant module:prim.mzero
     * @static
     * @type {AbstractParser}
     */
    const mzero = new Parser(state => Result.eerr(ParseError.unknown(state.pos)));

    /**
     * @function module:prim.mplus
     * @static
     * @param {AbstractParser} parserA
     * @param {AbstractParser} parserB
     * @returns {AbstractParser}
     */
    function mplus(parserA, parserB) {
        return new Parser(state => {
            const resA = parserA.run(state);
            if (!resA.consumed && !resA.success) {
                const resB = parserB.run(state);
                return resB.consumed
                    ? resB
                    : new Result(
                        resB.consumed,
                        resB.success,
                        ParseError.merge(resA.err, resB.err),
                        resB.val,
                        resB.state
                    );
            }
            else {
                return resA;
            }
        });
    }

    /**
     * @function module:prim.label
     * @static
     * @param {AbstractParser} parser
     * @param {string} labelStr
     * @returns {AbstractParser}
     */
    function label(parser, labelStr) {
        return labels(parser, [labelStr]);
    }

    /**
     * @function module:prim.labels
     * @static
     * @param {AbstractParser} parser
     * @param {Array.<string>} labelStrs
     * @returns {AbstractParser}
     */
    function labels(parser, labelStrs) {
        function setExpects(err) {
            return err.setSpecificTypeMessages(ErrorMessageType.EXPECT, labelStrs.length === 0 ? [""] : labelStrs);
        }
        return new Parser(state => {
            const res = parser.run(state);
            if (res.consumed) {
                return res;
            }
            else {
                return new Result(
                    false,
                    res.success,
                    res.success
                        ? new LazyParseError(() => res.err.isUnknown() ? res.err : setExpects(res.err))
                        : setExpects(res.err),
                    res.val,
                    res.state
                );
            }
        });
    }

    /**
     * @function module:prim.hidden
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function hidden(parser) {
        return label(parser, "");
    }

    /**
     * @function module:prim.unexpected
     * @static
     * @param {string} msgStr
     * @returns {AbstractParser}
     */
    function unexpected(msgStr) {
        return new Parser(state => Result.eerr(
            new ParseError(
                state.pos,
                [new ErrorMessage(ErrorMessageType.UNEXPECT, msgStr)]
            )
        ));
    }

    /**
     * @function module:prim.tryParse
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function tryParse(parser) {
        return new Parser(state => {
            const res = parser.run(state);
            return res.consumed && !res.success
                ? Result.eerr(res.err)
                : res;
        });
    }

    /**
     * @function module:prim.lookAhead
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function lookAhead(parser) {
        return new Parser(state => {
            const res = parser.run(state);
            return res.success
                ? Result.esuc(ParseError.unknown(state.pos), res.val, state)
                : res;
        });
    }

    /**
     * @function module:prim.reduceMany
     * @static
     * @param {AbstractParser} parser
     * @param {function} callback
     * @param {*} initVal
     * @returns {AbstractParser}
     * @throws {Error} `parser` accepts an empty string.
     */
    function reduceMany(parser, callback, initVal) {
        return new Parser(state => {
            let accum = initVal;
            let consumed = false;
            let currentState = state;
            while (true) {
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum = callback(accum, res.val);
                        currentState = res.state;
                    }
                    else {
                        throw new Error("`many' is applied to a parser that accepts an empty string");
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.csuc(res.err, accum, currentState)
                            : Result.esuc(res.err, accum, currentState);
                    }
                }
            }
        });
    }

    /**
     * @function module:prim.many
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     * @throws {Error} `parser` accepts an empty string.
     */
    function many(parser) {
        return new Parser(state => {
            const accum = [];
            let consumed = false;
            let currentState = state;
            while (true) {
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum.push(res.val);
                        currentState = res.state;
                    }
                    else {
                        throw new Error("`many' is applied to a parser that accepts an empty string");
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.csuc(res.err, accum, currentState)
                            : Result.esuc(res.err, accum, currentState);
                    }
                }
            }
        });
    }

    /**
     * @function module:prim.skipMany
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     * @throws {Error} `parser` accepts an empty string.
     */
    function skipMany(parser) {
        return reduceMany(parser, accum => accum, undefined);
    }

    /**
     * @function module:prim.tokens
     * @static
     * @param {Array.<*>} expectTokens
     * @param {function} tokenEqual
     * @param {function} tokensToString
     * @param {function} calcNextPos
     * @returns {AbstractParser}
     */
    function tokens(expectTokens, tokenEqual, tokensToString, calcNextPos) {
        function eofError(pos) {
            return new ParseError(
                pos,
                [
                    new ErrorMessage(ErrorMessageType.SYSTEM_UNEXPECT, ""),
                    new ErrorMessage(ErrorMessageType.EXPECT, tokensToString(expectTokens))
                ]
            );
        }
        function expectError(pos, token) {
            return new ParseError(
                pos,
                [
                    new ErrorMessage(ErrorMessageType.SYSTEM_UNEXPECT, tokensToString([token])),
                    new ErrorMessage(ErrorMessageType.EXPECT, tokensToString(expectTokens))
                ]
            );
        }
        return new Parser(state => {
            const len = expectTokens.length;
            if (len === 0) {
                return Result.esuc(ParseError.unknown(state.pos), [], state);
            }
            let rest = state.input;
            for (let i = 0; i < len; i++) {
                const unconsed = uncons(rest, state.config.unicode);
                if (unconsed.empty) {
                    return i === 0
                        ? Result.eerr(eofError(state.pos))
                        : Result.cerr(eofError(state.pos));
                }
                else {
                    if (tokenEqual(expectTokens[i], unconsed.head)) {
                        rest = unconsed.tail;
                    }
                    else {
                        return i === 0
                            ? Result.eerr(expectError(state.pos, unconsed.head))
                            : Result.cerr(expectError(state.pos, unconsed.head));
                    }
                }
            }
            const newPos = calcNextPos(state.pos, expectTokens, state.config);
            return Result.csuc(
                ParseError.unknown(newPos),
                expectTokens,
                new State(state.config, rest, newPos, state.userState)
            );
        });
    }

    /**
     * @function module:prim.token
     * @static
     * @param {function} calcValue
     * @param {function} tokenToString
     * @param {function} calcPos
     * @returns {AbstractParser}
     */
    function token(calcValue, tokenToString, calcPos) {
        function calcNextPos(pos, token, rest, config) {
            const unconsed = uncons(rest, config.unicode);
            return unconsed.empty
                ? calcPos(token, config)
                : calcPos(unconsed.head, config);
        }
        return tokenPrim(calcValue, tokenToString, calcNextPos);
    }

    /**
     * @function module:prim.tokenPrim
     * @static
     * @param {function} calcValue
     * @param {function} tokenToString
     * @param {function} calcNextPos
     * @param {function} [calcNextUserState = x => x]
     * @returns {AbstractParser}
     */
    function tokenPrim(calcValue, tokenToString, calcNextPos, calcNextUserState) {
        function systemUnexpectError(pos, str) {
            return new ParseError(
                pos,
                [new ErrorMessage(ErrorMessageType.SYSTEM_UNEXPECT, str)]
            );
        }
        return new Parser(state => {
            const unconsed = uncons(state.input, state.config.unicode);
            if (unconsed.empty) {
                return Result.eerr(systemUnexpectError(state.pos, ""));
            }
            else {
                const maybeVal = calcValue(unconsed.head, state.config);
                if (maybeVal.empty) {
                    return Result.eerr(systemUnexpectError(state.pos, tokenToString(unconsed.head)));
                }
                else {
                    const newPos = calcNextPos(state.pos, unconsed.head, unconsed.tail, state.config);
                    const newUserState = calcNextUserState === undefined
                        ? state.userState
                        : calcNextUserState(state.userState, state.pos, unconsed.head, unconsed.tail, state.config);
                    return Result.csuc(
                        ParseError.unknown(newPos),
                        maybeVal.value,
                        new State(state.config, unconsed.tail, newPos, newUserState)
                    );
                }
            }
        });
    }

    /**
     * @constant module:prim.getParserState
     * @static
     * @type {AbstractParser}
     */
    const getParserState = new Parser(state => Result.esuc(ParseError.unknown(state.pos), state, state));

    /**
     * @function module:prim.setParserState
     * @static
     * @param {State} state
     * @returns {AbstractParser}
     */
    function setParserState(state) {
        return updateParserState(() => state);
    }

    /**
     * @function module:prim.updateParserState
     * @static
     * @param {function} func
     * @returns {AbstractParser}
     */
    function updateParserState(func) {
        return new Parser(state => {
            const newState = func(state);
            return Result.esuc(ParseError.unknown(newState.pos), newState, newState);
        });
    }

    /**
     * @constant module:prim.getConfig
     * @static
     * @type {AbstractParser}
     */
    const getConfig = bind(getParserState, state => pure(state.config));

    /**
     * @function module:prim.setConfig
     * @static
     * @param {Config} config
     * @returns {AbstractParser}
     */
    function setConfig(config) {
        return then(
            updateParserState(state => state.setConfig(config)),
            pure(undefined)
        );
    }

    /**
     * @constant module:prim.getInput
     * @static
     * @type {AbstractParser}
     */
    const getInput = bind(getParserState, state => pure(state.input));

    /**
     * @function module:prim.setInput
     * @static
     * @param {(string|Array|IStream)} input
     * @returns {AbstractParser}
     */
    function setInput(input) {
        return then(
            updateParserState(state => state.setInput(input)),
            pure(undefined)
        );
    }

    /**
     * @constant module:prim.getPosition
     * @static
     * @type {AbstractParser}
     */
    const getPosition = bind(getParserState, state => pure(state.pos));

    /**
     * @function module:prim.setPosition
     * @static
     * @param {SourcePos} pos
     * @returns {AbstractParser}
     */
    function setPosition(pos) {
        return then(
            updateParserState(state => state.setPosition(pos)),
            pure(undefined)
        );
    }

    /**
     * @constant module:prim.getState
     * @static
     * @type {AbstractParser}
     */
    const getState = bind(getParserState, state => pure(state.userState));

    /**
     * @function module:prim.setState
     * @static
     * @param {*} userState
     * @returns {AbstractParser}
     */
    function setState(userState) {
        return then(
            updateParserState(state => state.setUserState(userState)),
            pure(undefined)
        );
    }

    return end();
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-prim / sugar.js
 */

/**
 * @module sugar
 */



module.exports = (_core, _prim) => {
    const isParser = _core.isParser;

    const map        = _prim.map;
    const pure       = _prim.pure;
    const ap         = _prim.ap;
    const left       = _prim.left;
    const right      = _prim.right;
    const bind       = _prim.bind;
    const then       = _prim.then;
    const fail       = _prim.fail;
    const mplus      = _prim.mplus;
    const label      = _prim.label;
    const hidden     = _prim.hidden;
    const tryParse   = _prim.tryParse;
    const lookAhead  = _prim.lookAhead;
    const reduceMany = _prim.reduceMany;
    const many       = _prim.many;
    const skipMany   = _prim.skipMany;

    return Object.freeze({
        map: function (func) {
            return map(this, func);
        },
        return: function (val) {
            return then(this, pure(val));
        },
        ap: function (parser) {
            return ap(this, parser);
        },
        left: function (parser) {
            return left(this, parser);
        },
        skip: function (parser) {
            return left(this, parser);
        },
        right: function (parser) {
            return right(this, parser);
        },
        bind: function (func) {
            return bind(this, func);
        },
        and: function (parser) {
            return then(this, parser);
        },
        fail: function (msgStr) {
            return then(this, fail(msgStr));
        },
        done: function () {
            return map(this, x => ({ done: true, value: x }));
        },
        cont: function () {
            return map(this, x => ({ done: false, value: x }));
        },
        or: function (parser) {
            return mplus(this, parser);
        },
        label: function (labelStr) {
            return label(this, labelStr);
        },
        hidden: function () {
            return hidden(this);
        },
        try: function () {
            return tryParse(this);
        },
        lookAhead: function () {
            return lookAhead(this);
        },
        reduceMany: function (callback, initVal) {
            return reduceMany(this, callback, initVal);
        },
        many: function () {
            return many(this);
        },
        skipMany: function (parser) {
            return isParser(parser)
                ? left(this, skipMany(parser))
                : skipMany(this);
        }
    });
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-qo
 */



module.exports = _core => {
    let _qo = __webpack_require__(27)(_core);

    return Object.freeze({
        qo: _qo.qo,
        do: _qo.qo
    });
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-qo / qo.js
 */

/**
 * @module qo
 */



module.exports = _core => {
    function end() {
        return Object.freeze({
            qo
        });
    }

    const ParseError = _core.ParseError;
    const Result     = _core.Result;
    const Parser     = _core.Parser;
    const isParser   = _core.isParser;

    /**
     * @function module:qo.qo
     * @static
     * @param {GeneratorFunction} genFunc
     * @returns {AbstractParser}
     */
    function qo(genFunc) {
        return new Parser(state => {
            const gen = genFunc();

            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;

            let genRes;
            try {
                genRes = gen.next();
            }
            catch (err) {
                if (isParser(err)) {
                    const errRes = err.run(currentState);
                    if (errRes.success) {
                        return errRes.consumed
                            ? Result.cerr(errRes.err)
                            : Result.eerr(ParseError.merge(currentErr, errRes.err));
                    }
                    else {
                        return errRes.consumed
                            ? errRes
                            : Result.eerr(ParseError.merge(currentErr, errRes.err));
                    }
                }
                else {
                    throw err;
                }
            }

            while (!genRes.done) {
                const res = genRes.value.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }

                try {
                    genRes = gen.next(res.val);
                }
                catch (err) {
                    if (isParser(err)) {
                        const errRes = err.run(currentState);
                        if (errRes.success) {
                            return errRes.consumed
                                ? Result.cerr(errRes.err)
                                : Result.eerr(ParseError.merge(currentErr, errRes.err));
                        }
                        else {
                            return errRes.consumed
                                ? errRes
                                : Result.eerr(ParseError.merge(currentErr, errRes.err));
                        }
                    }
                    else {
                        throw err;
                    }
                }
            }

            return consumed
                ? Result.csuc(currentErr, genRes.value, currentState)
                : Result.esuc(currentErr, genRes.value, currentState);
        });
    }

    return end();
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat
 */



module.exports = opts => {
    if (opts === undefined) {
        opts = {};
    }

    const _core = __webpack_require__(13)();

    const _loquat = Object.assign({}, _core);

    Object.defineProperties(_loquat, {
        "extensions": {
            writable    : false,
            configurable: false,
            enumerable  : true,
            value       : {}
        },
        "use": {
            writable    : false,
            configurable: false,
            enumerable  : true,
            value       : use
        }
    });

    /**
     * @param {Function} ext
     * @param {Object} [opts = {}]
     * @returns {*}
     */
    function use(ext, opts) {
        if (opts === undefined) {
            opts = {};
        }
        const _ext = ext(_core, opts.options);
        if (!opts.qualified) {
            Object.assign(_loquat, _ext);
        }
        if (opts.name !== undefined) {
            _loquat.extensions[opts.name] = _ext;
        }
        return _ext;
    }

    if (!opts.noUsingDefaults) {
        use(__webpack_require__(0),        { name: "prim",        options: { sugar: true } });
        use(__webpack_require__(8),        { name: "char",        options: { sugar: true } });
        use(__webpack_require__(2), { name: "combinators", options: { sugar: true } });
        use(__webpack_require__(21),       { name: "monad",       options: { sugar: true } });
        use(__webpack_require__(19),        { name: "expr",        options: {} });
        use(__webpack_require__(26),          { name: "qo",          options: {} });
    }

    return _loquat;
};


/***/ })
/******/ ]);