var whitespace =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/*
 * Whitespace-JS / utils.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        SPACE,
        TAB,
        LF,

        intToWhitespace,
        labelToWhitespace
    });
}

const SPACE = " ";
const TAB   = "\t";
const LF    = "\n";

function intToWhitespace(n) {
    n = n | 0;
    let sign;
    if (n >= 0) {
        sign = SPACE;
    }
    else {
        sign = TAB;
        n    = -n;
    }
    let bits = "";
    while (n > 0) {
        bits = ((n & 1) === 0 ? SPACE : TAB) + bits;
        n    = n >> 1;
    }
    return sign + bits + LF;
}

function labelToWhitespace(label) {
    const buf = Buffer.from(label, "utf8");
    const len = buf.length;
    let ws  = "";
    for (let offset = 0; offset < len; offset++) {
        let n = buf.readUInt8(offset);
        let c = "";
        for (let i = 0; i < 8; i++) {
            c = (n & 1 ? TAB : SPACE) + c;
            n = n >>> 1;
        }
        ws += c;
    }
    return ws + LF;
}

end();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(45).Buffer))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS / inst/inst.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        Instruction
    });
}

const error = __webpack_require__(5);

class Instruction {
    constructor(pos) {
        this.pos = pos;
    }

    toString() {
        return this.toUnWhitespace();
    }

    toWhitespace() {
        throw new Error("unknown instruction");
    }

    toUnWhitespace() {
        throw new Error("unknown instruction");
    }

    do(vm) {
        try {
            return this.doSub(vm);
        }
        catch (e) {
            throw new error.RuntimeError(this.pos, String(e));
        }
    }

    doSub() {
        throw new Error("unknown instruction");
    }
}

end();


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-prim
 */



module.exports = (_core, opts) => {
    if (opts === undefined) {
        opts = {};
    }

    const _prim = __webpack_require__(36)(_core);

    if (opts.sugar) {
        const _sugar = __webpack_require__(37)(_core, _prim);
        _core.extendParser(_sugar);
    }

    return Object.freeze({
        map              : _prim.map,
        fmap             : _prim.fmap,
        pure             : _prim.pure,
        return           : _prim.pure,
        ap               : _prim.ap,
        left             : _prim.left,
        right            : _prim.right,
        bind             : _prim.bind,
        then             : _prim.then,
        and              : _prim.then,
        fail             : _prim.fail,
        tailRecM         : _prim.tailRecM,
        ftailRecM        : _prim.ftailRecM,
        mzero            : _prim.mzero,
        mplus            : _prim.mplus,
        or               : _prim.mplus,
        label            : _prim.label,
        labels           : _prim.labels,
        hidden           : _prim.hidden,
        unexpected       : _prim.unexpected,
        tryParse         : _prim.tryParse,
        try              : _prim.tryParse,
        lookAhead        : _prim.lookAhead,
        reduceMany       : _prim.reduceMany,
        many             : _prim.many,
        skipMany         : _prim.skipMany,
        tokens           : _prim.tokens,
        token            : _prim.token,
        tokenPrim        : _prim.tokenPrim,
        getParserState   : _prim.getParserState,
        setParserState   : _prim.setParserState,
        updateParserState: _prim.updateParserState,
        getConfig        : _prim.getConfig,
        setConfig        : _prim.setConfig,
        getInput         : _prim.getInput,
        setInput         : _prim.setInput,
        getPosition      : _prim.getPosition,
        setPosition      : _prim.setPosition,
        getState         : _prim.getState,
        setState         : _prim.setState
    });
};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS / inst.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        Instruction: inst.Instruction,

        StackManipulation: stack.StackManipulation,
        Push             : stack.Push,      // push <n>
        Refer            : stack.Refer,     // refer <n>
        Slide            : stack.Slide,     // slide <n>
        Duplicate        : stack.Duplicate, // duplicate
        Swap             : stack.Swap,      // swap
        Discard          : stack.Discard,   // discard

        Arithmetic: arith.Arithmetic,
        Add       : arith.Add,      // add
        Subtract  : arith.Subtract, // subtract
        Multiple  : arith.Multiple, // multiple
        Divide    : arith.Divide,   // divide
        Modulo    : arith.Modulo,   // modulo

        HeapAccess: heap.HeapAccess,
        Store     : heap.Store,     // store
        Retrieve  : heap.Retrieve,  // retrieve

        IO     : io.IO,
        PutChar: io.PutChar,    // putchar
        Print  : io.Print,      // print
        GetChar: io.GetChar,    // getchar
        Read   : io.Read,       // read

        FlowControl: flow.FlowControl,
        Mark       : flow.Mark,         // mark <label>
        Call       : flow.Call,         // call <label>
        Jump       : flow.Jump,         // jump <label>
        IfZero     : flow.IfZero,       // ifzero <label>
        IfNegative : flow.IfNegative,   // ifnegative <label>
        Return     : flow.Return,       // return
        End        : flow.End,          // end

        compile
    });
}

const inst  = __webpack_require__(1);
const stack = __webpack_require__(15);
const arith = __webpack_require__(11);
const heap  = __webpack_require__(13);
const io    = __webpack_require__(14);
const flow  = __webpack_require__(12);

function compile(prog) {
    prog = prog.slice();
    let len = prog.length;
    const labelMap = new Map();
    for (let i = 0; i < len; i++) {
        if (prog[i] instanceof flow.Mark) {
            labelMap.set(prog[i].label, i);
            prog.splice(i, 1);
            i   -= 1;
            len -= 1;
        }
    }
    for (let i = 0; i < len; i++) {
        if (prog[i] instanceof flow.Call) {
            const index = labelMap.get(prog[i].label);
            if (index === undefined) {
                throw new Error(prog[i].pos.toString() + ":\nunknown label " + prog[i].label.toString());
            }
            prog[i] = new flow.Call2(prog[i].pos, index, prog[i]);
        }
        else if (prog[i] instanceof flow.Jump) {
            const index = labelMap.get(prog[i].label);
            if (index === undefined) {
                throw new Error(prog[i].pos.toString() + ":\nunknown label " + prog[i].label.toString());
            }
            prog[i] = new flow.Jump2(prog[i].pos, index, prog[i]);
        }
        else if (prog[i] instanceof flow.IfZero) {
            const index = labelMap.get(prog[i].label);
            if (index === undefined) {
                throw new Error(prog[i].pos.toString() + ":\nunknown label " + prog[i].label.toString());
            }
            prog[i] = new flow.IfZero2(prog[i].pos, index, prog[i]);
        }
        else if (prog[i] instanceof flow.IfNegative) {
            const index = labelMap.get(prog[i].label);
            if (index === undefined) {
                throw new Error(prog[i].pos.toString() + ":\nunknown label " + prog[i].label.toString());
            }
            prog[i] = new flow.IfNegative2(prog[i].pos, index, prog[i]);
        }
    }
    return prog;
}

end();


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-combinators
 */



module.exports = (_core, opts) => {
    if (opts === undefined) {
        opts = {};
    }

    const _prim        = __webpack_require__(2)(_core);
    const _combinators = __webpack_require__(23)(_core, _prim);

    if (opts.sugar) {
        const _sugar = __webpack_require__(24)(_core, _prim, _combinators);
        _core.extendParser(_sugar);
    }

    return Object.freeze({
        choice        : _combinators.choice,
        option        : _combinators.option,
        optionMaybe   : _combinators.optionMaybe,
        optional      : _combinators.optional,
        between       : _combinators.between,
        many1         : _combinators.many1,
        skipMany1     : _combinators.skipMany1,
        sepBy         : _combinators.sepBy,
        sepBy1        : _combinators.sepBy1,
        sepEndBy      : _combinators.sepEndBy,
        sepEndBy1     : _combinators.sepEndBy1,
        endBy         : _combinators.endBy,
        endBy1        : _combinators.endBy1,
        count         : _combinators.count,
        chainl        : _combinators.chainl,
        chainl1       : _combinators.chainl1,
        chainr        : _combinators.chainr,
        chainr1       : _combinators.chainr1,
        anyToken      : _combinators.anyToken,
        notFollowedBy : _combinators.notFollowedBy,
        eof           : _combinators.eof,
        reduceManyTill: _combinators.reduceManyTill,
        manyTill      : _combinators.manyTill,
        skipManyTill  : _combinators.skipManyTill
    });
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS / error.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        RuntimeError
    });
}

class RuntimeError extends Error {
    constructor(pos, message) {
        super(message);
        this.pos = pos;
    }

    toString() {
        return this.pos.toString() + ":\n" + this.message;
    }
}

end();


/***/ }),
/* 6 */
/***/ (function(module, exports) {


/**
 * slice() reference.
 */

var slice = Array.prototype.slice;

/**
 * Expose `co`.
 */

module.exports = co['default'] = co.co = co;

/**
 * Wrap the given generator `fn` into a
 * function that returns a promise.
 * This is a separate function so that
 * every `co()` call doesn't create a new,
 * unnecessary closure.
 *
 * @param {GeneratorFunction} fn
 * @return {Function}
 * @api public
 */

co.wrap = function (fn) {
  createPromise.__generatorFunction__ = fn;
  return createPromise;
  function createPromise() {
    return co.call(this, fn.apply(this, arguments));
  }
};

/**
 * Execute the generator function or a generator
 * and return a promise.
 *
 * @param {Function} fn
 * @return {Promise}
 * @api public
 */

function co(gen) {
  var ctx = this;
  var args = slice.call(arguments, 1)

  // we wrap everything in a promise to avoid promise chaining,
  // which leads to memory leak errors.
  // see https://github.com/tj/co/issues/180
  return new Promise(function(resolve, reject) {
    if (typeof gen === 'function') gen = gen.apply(ctx, args);
    if (!gen || typeof gen.next !== 'function') return resolve(gen);

    onFulfilled();

    /**
     * @param {Mixed} res
     * @return {Promise}
     * @api private
     */

    function onFulfilled(res) {
      var ret;
      try {
        ret = gen.next(res);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }

    /**
     * @param {Error} err
     * @return {Promise}
     * @api private
     */

    function onRejected(err) {
      var ret;
      try {
        ret = gen.throw(err);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }

    /**
     * Get the next value in the generator,
     * return a promise.
     *
     * @param {Object} ret
     * @return {Promise}
     * @api private
     */

    function next(ret) {
      if (ret.done) return resolve(ret.value);
      var value = toPromise.call(ctx, ret.value);
      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '
        + 'but the following object was passed: "' + String(ret.value) + '"'));
    }
  });
}

/**
 * Convert a `yield`ed value into a promise.
 *
 * @param {Mixed} obj
 * @return {Promise}
 * @api private
 */

function toPromise(obj) {
  if (!obj) return obj;
  if (isPromise(obj)) return obj;
  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
  if ('function' == typeof obj) return thunkToPromise.call(this, obj);
  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
  if (isObject(obj)) return objectToPromise.call(this, obj);
  return obj;
}

/**
 * Convert a thunk to a promise.
 *
 * @param {Function}
 * @return {Promise}
 * @api private
 */

function thunkToPromise(fn) {
  var ctx = this;
  return new Promise(function (resolve, reject) {
    fn.call(ctx, function (err, res) {
      if (err) return reject(err);
      if (arguments.length > 2) res = slice.call(arguments, 1);
      resolve(res);
    });
  });
}

/**
 * Convert an array of "yieldables" to a promise.
 * Uses `Promise.all()` internally.
 *
 * @param {Array} obj
 * @return {Promise}
 * @api private
 */

function arrayToPromise(obj) {
  return Promise.all(obj.map(toPromise, this));
}

/**
 * Convert an object of "yieldables" to a promise.
 * Uses `Promise.all()` internally.
 *
 * @param {Object} obj
 * @return {Promise}
 * @api private
 */

function objectToPromise(obj){
  var results = new obj.constructor();
  var keys = Object.keys(obj);
  var promises = [];
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var promise = toPromise.call(this, obj[key]);
    if (promise && isPromise(promise)) defer(promise, key);
    else results[key] = obj[key];
  }
  return Promise.all(promises).then(function () {
    return results;
  });

  function defer(promise, key) {
    // predefine the key in the result
    results[key] = undefined;
    promises.push(promise.then(function (res) {
      results[key] = res;
    }));
  }
}

/**
 * Check if `obj` is a promise.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isPromise(obj) {
  return 'function' == typeof obj.then;
}

/**
 * Check if `obj` is a generator.
 *
 * @param {Mixed} obj
 * @return {Boolean}
 * @api private
 */

function isGenerator(obj) {
  return 'function' == typeof obj.next && 'function' == typeof obj.throw;
}

/**
 * Check if `obj` is a generator function.
 *
 * @param {Mixed} obj
 * @return {Boolean}
 * @api private
 */
function isGeneratorFunction(obj) {
  var constructor = obj.constructor;
  if (!constructor) return false;
  if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;
  return isGenerator(constructor.prototype);
}

/**
 * Check for plain object.
 *
 * @param {Mixed} val
 * @return {Boolean}
 * @api private
 */

function isObject(val) {
  return Object == val.constructor;
}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-char
 */



module.exports = (_core, opts) => {
    if (opts === undefined) {
        opts = {};
    }

    const _prim = __webpack_require__(2)(_core);
    const _char = __webpack_require__(21)(_core, _prim);

    if (opts.sugar) {
        const _sugar = __webpack_require__(22)(_core, _char);
        _core.extendParser(_sugar);
    }

    return Object.freeze({
        string    : _char.string,
        satisfy   : _char.satisfy,
        oneOf     : _char.oneOf,
        noneOf    : _char.noneOf,
        char      : _char.char,
        anyChar   : _char.anyChar,
        space     : _char.space,
        spaces    : _char.spaces,
        newline   : _char.newline,
        tab       : _char.tab,
        upper     : _char.upper,
        lower     : _char.lower,
        letter    : _char.letter,
        digit     : _char.digit,
        alphaNum  : _char.alphaNum,
        octDigit  : _char.octDigit,
        hexDigit  : _char.hexDigit,
        manyChars : _char.manyChars,
        manyChars1: _char.manyChars1,
        regexp    : _char.regexp
    });
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat
 */



module.exports = opts => {
    if (opts === undefined) {
        opts = {};
    }

    const _core = __webpack_require__(25)();

    const _loquat = Object.assign({}, _core);

    Object.defineProperties(_loquat, {
        "extensions": {
            writable    : false,
            configurable: false,
            enumerable  : true,
            value       : {}
        },
        "use": {
            writable    : false,
            configurable: false,
            enumerable  : true,
            value       : use
        }
    });

    /**
     * @param {Function} ext
     * @param {Object} [opts = {}]
     * @returns {*}
     */
    function use(ext, opts) {
        if (opts === undefined) {
            opts = {};
        }
        const _ext = ext(_core, opts.options);
        if (!opts.qualified) {
            Object.assign(_loquat, _ext);
        }
        if (opts.name !== undefined) {
            _loquat.extensions[opts.name] = _ext;
        }
        return _ext;
    }

    if (!opts.noUsingDefaults) {
        use(__webpack_require__(2),        { name: "prim",        options: { sugar: true } });
        use(__webpack_require__(7),        { name: "char",        options: { sugar: true } });
        use(__webpack_require__(4), { name: "combinators", options: { sugar: true } });
        use(__webpack_require__(33),       { name: "monad",       options: { sugar: true } });
        use(__webpack_require__(31),        { name: "expr",        options: {} });
        use(__webpack_require__(38),          { name: "qo",          options: {} });
    }

    return _loquat;
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS
 * copyright (c) 2016 Susisu
 */



module.exports = __webpack_require__(20);


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// NOTE: hacked together to expose an execute script tag as whitespace function,
//        returning a promise that resolves with stdout and the return value

const ws = __webpack_require__(9);

module.exports = (sel, input) => new Promise((resolve, reject) => {
  try {
    const { text } = document.querySelector(sel);
    let stdout = '';
    ws.vm.run(ws.parser.ws(sel, text), input, x => stdout += x, () => {}, () => {}).then(ret => {
      resolve({ stdout, return: 0 });
    });
  } catch(e) {
    console.error('err', e);
    reject(`Whitespace interpretation failed: ${e}`);
  }
});


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS / inst/arith.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        Arithmetic,
        Add,
        Subtract,
        Multiple,
        Divide,
        Modulo
    });
}

const utils = __webpack_require__(0);
const inst  = __webpack_require__(1);

class Arithmetic extends inst.Instruction {
    constructor(pos) {
        super(pos);
    }

    toWhitespace() {
        return utils.TAB + utils.SPACE + this.toSubWhitespace();
    }

    toSubWhitespace() {
        throw new Error("unknown instruction");
    }
}

class Add extends Arithmetic {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.SPACE + utils.SPACE;
    }

    toUnWhitespace() {
        return "add";
    }

    doSub(vm) {
        const b = vm.state.pop();
        const a = vm.state.pop();
        vm.state.push((a + b) | 0);
    }
}

class Subtract extends Arithmetic {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.SPACE + utils.TAB;
    }

    toUnWhitespace() {
        return "subtract";
    }

    doSub(vm) {
        const b = vm.state.pop();
        const a = vm.state.pop();
        vm.state.push((a - b) | 0);
    }
}

class Multiple extends Arithmetic {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.SPACE + utils.LF;
    }

    toUnWhitespace() {
        return "multiple";
    }

    doSub(vm) {
        const b = vm.state.pop();
        const a = vm.state.pop();
        vm.state.push((a * b) | 0);
    }
}

class Divide extends Arithmetic {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.TAB + utils.SPACE;
    }

    toUnWhitespace() {
        return "divide";
    }

    doSub(vm) {
        const b = vm.state.pop();
        const a = vm.state.pop();
        vm.state.push((a / b) | 0);
    }
}

class Modulo extends Arithmetic {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.TAB + utils.TAB;
    }

    toUnWhitespace() {
        return "modulo";
    }

    doSub(vm) {
        const b = vm.state.pop();
        const a = vm.state.pop();
        vm.state.push((a % b) | 0);
    }
}

end();


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS / inst/flow.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        FlowControl,
        Mark,
        Call,
        Call2,
        Jump,
        Jump2,
        IfZero,
        IfZero2,
        IfNegative,
        IfNegative2,
        Return,
        End
    });
}

const utils = __webpack_require__(0);
const inst  = __webpack_require__(1);

class FlowControl extends inst.Instruction {
    constructor(pos) {
        super(pos);
    }

    toWhitespace() {
        return utils.LF + this.toSubWhitespace();
    }

    toSubWhitespace() {
        throw new Error("unknown instruction");
    }
}

class Mark extends FlowControl {
    constructor(pos, label) {
        super(pos);
        this.label = label;
    }

    toSubWhitespace() {
        return utils.SPACE + utils.SPACE + utils.labelToWhitespace(this.label);
    }

    toUnWhitespace() {
        return "mark " + JSON.stringify(this.label);
    }

    doSub() {
        // do nothing
    }
}

class Call extends FlowControl {
    constructor(pos, label) {
        super(pos);
        this.label = label;
    }

    toSubWhitespace() {
        return utils.SPACE + utils.TAB + utils.labelToWhitespace(this.label);
    }

    toUnWhitespace() {
        return "call " + JSON.stringify(this.label);
    }

    doSub(vm) {
        const index = vm.findLabel(this.label);
        vm.state.call(index);
    }
}

class Call2 extends FlowControl {
    constructor(pos, index, orig) {
        super(pos);
        this.index = index;
        this.orig  = orig;
    }

    toSubWhitespace() {
        throw new Error("cannot convert to Whitespace");
    }

    toUnWhitespace() {
        if (this.orig) {
            return this.orig.toUnWhitespace();
        }
        else {
            return "call2 " + this.index.toString();
        }
    }

    doSub(vm) {
        vm.state.call(this.index);
    }
}

class Jump extends FlowControl {
    constructor(pos, label) {
        super(pos);
        this.label = label;
    }

    toSubWhitespace() {
        return utils.SPACE + utils.LF + utils.labelToWhitespace(this.label);
    }

    toUnWhitespace() {
        return "jump " + JSON.stringify(this.label);
    }

    doSub(vm) {
        const index = vm.findLabel(this.label);
        vm.state.jump(index);
    }
}

class Jump2 extends FlowControl {
    constructor(pos, index, orig) {
        super(pos);
        this.index = index;
        this.orig  = orig;
    }

    toSubWhitespace() {
        throw new Error("cannot convert to Whitespace");
    }

    toUnWhitespace() {
        if (this.orig) {
            return this.orig.toUnWhitespace();
        }
        else {
            return "jump2 " + this.index.toString();
        }
    }

    doSub(vm) {
        vm.state.jump(this.index);
    }
}

class IfZero extends FlowControl {
    constructor(pos, label) {
        super(pos);
        this.label = label;
    }

    toSubWhitespace() {
        return utils.TAB + utils.SPACE + utils.labelToWhitespace(this.label);
    }

    toUnWhitespace() {
        return "ifzero " + JSON.stringify(this.label);
    }

    doSub(vm) {
        const n = vm.state.pop();
        if (n === 0) {
            const index = vm.findLabel(this.label);
            vm.state.jump(index);
        }
    }
}

class IfZero2 extends FlowControl {
    constructor(pos, index, orig) {
        super(pos);
        this.index = index;
        this.orig  = orig;
    }

    toSubWhitespace() {
        throw new Error("cannot convert to Whitespace");
    }

    toUnWhitespace() {
        if (this.orig) {
            return this.orig.toUnWhitespace();
        }
        else {
            return "ifzero2 " + this.index.toString();
        }
    }

    doSub(vm) {
        const n = vm.state.pop();
        if (n === 0) {
            vm.state.jump(this.index);
        }
    }
}

class IfNegative extends FlowControl {
    constructor(pos, label) {
        super(pos);
        this.label = label;
    }

    toSubWhitespace() {
        return utils.TAB + utils.TAB + utils.labelToWhitespace(this.label);
    }

    toUnWhitespace() {
        return "ifnegative " + JSON.stringify(this.label);
    }

    doSub(vm) {
        const n = vm.state.pop();
        if (n < 0) {
            const index = vm.findLabel(this.label);
            vm.state.jump(index);
        }
    }
}

class IfNegative2 extends FlowControl {
    constructor(pos, index, orig) {
        super(pos);
        this.index = index;
        this.orig  = orig;
    }

    toSubWhitespace() {
        throw new Error("cannot convert to Whitespace");
    }

    toUnWhitespace() {
        if (this.orig) {
            return this.orig.toUnWhitespace();
        }
        else {
            return "ifnegative2 " + this.index.toString();
        }
    }

    doSub(vm) {
        const n = vm.state.pop();
        if (n < 0) {
            vm.state.jump(this.index);
        }
    }
}

class Return extends FlowControl {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.TAB + utils.LF;
    }

    toUnWhitespace() {
        return "return";
    }

    doSub(vm) {
        vm.state.return();
    }
}

class End extends FlowControl {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.LF + utils.LF;
    }

    toUnWhitespace() {
        return "end";
    }

    doSub(vm) {
        vm.quit(0);
    }
}

end();


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS / inst/heap.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        HeapAccess,
        Store,
        Retrieve
    });
}

const utils = __webpack_require__(0);
const inst  = __webpack_require__(1);

class HeapAccess extends inst.Instruction {
    constructor(pos) {
        super(pos);
    }

    toWhitespace() {
        return utils.TAB + utils.TAB + this.toSubWhitespace();
    }

    toSubWhitespace() {
        throw new Error("unknown instruction");
    }
}

class Store extends HeapAccess {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.SPACE;
    }

    toUnWhitespace() {
        return "store";
    }

    doSub(vm) {
        const n   = vm.state.pop();
        const loc = vm.state.pop();
        vm.state.store(loc, n);
    }
}

class Retrieve extends HeapAccess {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.TAB;
    }

    toUnWhitespace() {
        return "retrieve";
    }

    doSub(vm) {
        vm.state.push(vm.state.retrieve(vm.state.pop()));
    }
}

end();


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS / inst/io.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        IO,
        PutChar,
        Print,
        GetChar,
        Read
    });
}

const co = __webpack_require__(6);

const utils = __webpack_require__(0);
const inst  = __webpack_require__(1);

class IO extends inst.Instruction {
    constructor(pos) {
        super(pos);
    }

    toWhitespace() {
        return utils.TAB + utils.LF + this.toSubWhitespace();
    }

    toSubWhitespace() {
        throw new Error("unknown instruction");
    }
}

class PutChar extends IO {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.SPACE + utils.SPACE;
    }

    toUnWhitespace() {
        return "putchar";
    }

    doSub(vm) {
        const c = vm.state.pop(this.pos);
        vm.output(String.fromCharCode(c));
    }
}

class Print extends IO {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.SPACE + utils.TAB;
    }

    toUnWhitespace() {
        return "print";
    }

    doSub(vm) {
        const n = vm.state.pop(this.pos);
        vm.output(n.toString());
    }
}

class GetChar extends IO {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.TAB + utils.SPACE;
    }

    toUnWhitespace() {
        return "getchar";
    }

    doSub(vm) {
        const loc = vm.state.pop();
        return vm.input().then(c => {
            vm.state.store(loc, c.charCodeAt(0));
        });
    }
}

class Read extends IO {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.TAB + utils.TAB;
    }

    toUnWhitespace() {
        return "read";
    }

    doSub(vm) {
        const loc = vm.state.pop();
        return co(function* () {
            let str = "";
            while (true) {
                const c = yield vm.input();
                if (c === "\n") {
                    break;
                }
                str += c;
            }
            vm.state.store(loc, parseInt(str) | 0);
        });
    }
}

end();


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS / inst/stack.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        StackManipulation,
        Push,
        Refer,
        Slide,
        Duplicate,
        Swap,
        Discard
    });
}

const utils = __webpack_require__(0);
const inst  = __webpack_require__(1);

class StackManipulation extends inst.Instruction {
    constructor(pos) {
        super(pos);
    }

    toWhitespace() {
        return utils.SPACE + this.toSubWhitespace();
    }

    toSubWhitespace() {
        throw new Error("unknown instruction");
    }
}

class Push extends StackManipulation {
    constructor(pos, n) {
        super(pos);
        this.n = n;
    }

    toSubWhitespace() {
        return utils.SPACE + utils.intToWhitespace(this.n);
    }

    toUnWhitespace() {
        return "push " + this.n.toString();
    }

    doSub(vm) {
        vm.state.push(this.n);
    }
}

class Refer extends StackManipulation {
    constructor(pos, n) {
        super(pos);
        this.n = n;
    }

    toSubWhitespace() {
        return utils.TAB + utils.SPACE + utils.intToWhitespace(this.n);
    }

    toUnWhitespace() {
        return "refer " + this.n.toString();
    }

    doSub(vm) {
        vm.state.push(vm.state.refer(this.n));
    }
}

class Slide extends StackManipulation {
    constructor(pos, n) {
        super(pos);
        this.n = n;
    }

    toSubWhitespace() {
        return utils.TAB + utils.LF + utils.intToWhitespace(this.n);
    }

    toUnWhitespace() {
        return "slide " + this.n.toString();
    }

    doSub(vm) {
        vm.state.slide(this.n);
    }
}

class Duplicate extends StackManipulation {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.LF + utils.SPACE;
    }

    toUnWhitespace() {
        return "duplicate";
    }

    doSub(vm) {
        const n = vm.state.pop();
        vm.state.push(n);
        vm.state.push(n);
    }
}

class Swap extends StackManipulation {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.LF + utils.TAB;
    }

    toUnWhitespace() {
        return "swap";
    }

    doSub(vm) {
        const a = vm.state.pop();
        const b = vm.state.pop();
        vm.state.push(a);
        vm.state.push(b);
    }
}

class Discard extends StackManipulation {
    constructor(pos) {
        super(pos);
    }

    toSubWhitespace() {
        return utils.LF + utils.LF;
    }

    toUnWhitespace() {
        return "discard";
    }

    doSub(vm) {
        vm.state.pop();
    }
}

end();


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS / parser.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        ws  : ws.parse,
        unws: unws.parse
    });
}

const ws   = __webpack_require__(18);
const unws = __webpack_require__(17);

end();


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS / parser/unws.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        parse
    });
}

const lq = __webpack_require__(8)();
lq.use(__webpack_require__(40));

const inst  = __webpack_require__(3);

const def = new lq.LanguageDef({
    commentLine  : "#",
    idStart      : lq.letter,
    idLetter     : lq.alphaNum,
    caseSensitive: true
});
const tp = lq.makeTokenParser(def);

const integer = tp.integer
    .or(tp.charLiteral.map(c => c.charCodeAt(0)))
    .label("integer");

const label = tp.stringLiteral.label("label");

function noArgs(name, cons) {
    return lq.do(function* () {
        const pos = yield lq.getPosition;
        yield tp.reserved(name);
        return new cons(pos);
    });
}

function intArg(name, cons) {
    return lq.do(function* () {
        const pos = yield lq.getPosition;
        yield tp.reserved(name);
        const n = yield integer;
        return new cons(pos, n);
    });
}

function labelArg(name, cons) {
    return lq.do(function* () {
        const pos = yield lq.getPosition;
        yield tp.reserved(name);
        const l = yield label;
        return new cons(pos, l);
    });
}

const instruction = lq.choice([
    // stack manipulation
    intArg("push", inst.Push),
    intArg("refer", inst.Refer),
    intArg("slide", inst.Slide),
    noArgs("duplicate", inst.Duplicate),
    noArgs("swap", inst.Swap),
    noArgs("discard", inst.Discard),

    // arithmetic
    noArgs("add", inst.Add),
    noArgs("subtract", inst.Subtract),
    noArgs("multiple", inst.Multiple),
    noArgs("divide", inst.Divide),
    noArgs("modulo", inst.Modulo),

    // heap access
    noArgs("store", inst.Store),
    noArgs("retrieve", inst.Retrieve),

    // io
    noArgs("putchar", inst.PutChar),
    noArgs("print", inst.Print),
    noArgs("getchar", inst.GetChar),
    noArgs("read", inst.Read),

    // flow control
    labelArg("mark", inst.Mark),
    labelArg("call", inst.Call),
    labelArg("jump", inst.Jump),
    labelArg("ifzero", inst.IfZero),
    labelArg("ifnegative", inst.IfNegative),
    noArgs("return", inst.Return),
    noArgs("end", inst.End)
]).label("instruction");

const program = lq.do(function* () {
    yield tp.whiteSpace;
    const prog = yield instruction.many();
    yield lq.eof;
    return prog;
});

function parse(name, src) {
    const res = lq.parse(program, name, src, undefined, { tabWidth: 8 });
    if (res.success) {
        return res.value;
    }
    else {
        throw res.error;
    }
}

end();


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS / parser/ws.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        parse
    });
}

const lq = __webpack_require__(8)();

const utils = __webpack_require__(0);
const inst  = __webpack_require__(3);

const SPACE = utils.SPACE;
const TAB   = utils.TAB;
const LF    = utils.LF;

const comment = lq.noneOf(SPACE + TAB + LF).skipMany().hidden();
function lexeme(p) {
    return p.skip(comment);
}

const space = lexeme(lq.char(SPACE)).label("space");
const tab   = lexeme(lq.char(TAB)).label("tab");
const lf    = lexeme(lq.char(LF)).label("line feed");
const token = lq.choice([space, tab, lf]);

const stack = space.void();
const arith = tab.and(space).void();
const heap  = tab.and(tab).void();
const io    = tab.and(lf).void();
const flow  = lf.void();

const integer = lq.do(function* () {
    const sign = yield space.return(1).or(tab.return(-1));
    let n = 0;
    while (true) {
        const tok = yield token;
        switch (tok) {
        case SPACE:
            n = n << 1;
            break;
        case TAB:
            n = (n << 1) | 1;
            break;
        case LF:
            return (sign * n) | 0;
        default:
            // ignore
        }
    }
}).label("integer");

const label = space.or(tab).manyChars().left(lf).label("label");

function noArgs(imp, command, cons) {
    return lq.do(function* () {
        const pos = yield lq.getPosition;
        yield imp;
        yield command;
        return new cons(pos);
    }).try();
}

function intArg(imp, command, cons) {
    return lq.do(function* () {
        const pos = yield lq.getPosition;
        yield imp;
        yield command;
        const n = yield integer;
        return new cons(pos, n);
    }).try();
}

function labelArg(imp, command, cons) {
    return lq.do(function* () {
        const pos = yield lq.getPosition;
        yield imp;
        yield command;
        const l = yield label;
        return new cons(pos, l);
    }).try();
}

const instruction = lq.choice([
    // stack manipulation
    intArg(stack, space, inst.Push),
    intArg(stack, tab.and(space), inst.Refer),
    intArg(stack, tab.and(lf), inst.Slide),
    noArgs(stack, lf.and(space), inst.Duplicate),
    noArgs(stack, lf.and(tab), inst.Swap),
    noArgs(stack, lf.and(lf), inst.Discard),

    // arithmetic
    noArgs(arith, space.and(space), inst.Add),
    noArgs(arith, space.and(tab), inst.Subtract),
    noArgs(arith, space.and(lf), inst.Multiple),
    noArgs(arith, tab.and(space), inst.Divide),
    noArgs(arith, tab.and(tab), inst.Modulo),

    // heap access
    noArgs(heap, space, inst.Store),
    noArgs(heap, tab, inst.Retrieve),

    // io
    noArgs(io, space.and(space), inst.PutChar),
    noArgs(io, space.and(tab), inst.Print),
    noArgs(io, tab.and(space), inst.GetChar),
    noArgs(io, tab.and(tab), inst.Read),

    // flow control
    labelArg(flow, space.and(space), inst.Mark),
    labelArg(flow, space.and(tab), inst.Call),
    labelArg(flow, space.and(lf), inst.Jump),
    labelArg(flow, tab.and(space), inst.IfZero),
    labelArg(flow, tab.and(tab), inst.IfNegative),
    noArgs(flow, tab.and(lf), inst.Return),
    noArgs(flow, lf.and(lf), inst.End)
]).label("instruction");

const program = lq.do(function* () {
    yield comment;
    const prog = yield instruction.many();
    yield lq.eof;
    return prog;
});

function parse(name, src) {
    const res = lq.parse(program, name, src, undefined, { tabWidth: 8 });
    if (res.success) {
        return res.value;
    }
    else {
        throw res.error;
    }
}

end();


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS / vm.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        State,
        VM,
        run
    });
}

const co = __webpack_require__(6);

const inst = __webpack_require__(3);

class State {
    constructor(progCount, callStack, stack, heap) {
        this.progCount = progCount; // program counter (index of list)
        this.callStack = callStack; // call stack
        this.stack     = stack;     // value stack
        this.heap      = heap;      // permanent memory
    }

    push(n) {
        this.stack.push(n);
    }

    pop() {
        if (this.stack.length === 0) {
            throw new Error("empty stack");
        }
        return this.stack.pop();
    }

    refer(i) {
        const len = this.stack.length;
        if (i < 0 || len <= i) {
            throw new Error("index out of range");
        }
        return this.stack[len - 1 - i];
    }

    slide(n) {
        const len = this.stack.length;
        if (len === 0) {
            throw new Error("empty stack");
        }
        this.stack.splice(len - 1 - n, n);
    }

    store(loc, n) {
        this.heap[loc] = n;
    }

    retrieve(loc) {
        return this.heap[loc] | 0;
    }

    call(index) {
        this.callStack.push(this.progCount);
        this.progCount = index;
    }

    jump(index) {
        this.progCount = index;
    }

    return() {
        if (this.callStack.length === 0) {
            throw new Error("no location to return");
        }
        this.progCount = this.callStack.pop();
    }
}

class VM {
    constructor(prog, input, output, quit) {
        this.prog   = prog;                     // program (list of instructions)
        this.input  = input;                    // input function (returns a Promise)
        this.output = output;                   // output function
        this.quit   = quit;                     // quit function
        this.state  = new State(0, [], [], []); // VM state
    }

    proceed() {
        const i = this.state.progCount;
        this.state.progCount += 1;
        return this.prog[i];
    }

    findLabel(label) {
        const len = this.prog.length;
        for (let i = 0; i < len; i++) {
            if (this.prog[i] instanceof inst.Mark) {
                if (label === this.prog[i].label) {
                    return i;
                }
            }
        }
        throw new Error("unknown label: " + label.toString());
    }
}

function run(prog, input, output, eoutput, quit, debug, warnings) {
    const vm  = new VM(prog, input, output, quit);
    if (debug) {
        output("\t\t" + stackDump(vm.state.stack) + "\n");
        output("\t\t" + heapDump(vm.state.heap) + "\n");
    }
    const len = vm.prog.length;
    return co(function* () {
        while (vm.state.progCount < len) {
            const inst = vm.proceed();
            if (debug) {
                output("\t" + inst.toUnWhitespace() + "\n");
            }
            const res = inst.do(vm);
            if (res instanceof Promise) {
                yield res;
            }
            if (debug) {
                output("\t\t" + stackDump(vm.state.stack) + "\n");
                output("\t\t" + heapDump(vm.state.heap) + "\n");
            }
        }
        if (warnings) {
            eoutput("Warning: unexpected end of program\n");
        }
        vm.quit(0);
    });
}

function stackDump(stack) {
    return stack.slice().reverse().map(n => n.toString()).concat("[]").join(":");
}

function heapDump(heap) {
    const entries = [];
    const addrs   = Object.keys(heap);
    for (const addr of addrs) {
        entries.push(addr.toString() + ":" + heap[addr].toString());
    }
    return "{" + entries.join(",") + "}";
}

end();


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Whitespace-JS / ws.js
 * copyright (c) 2016 Susisu
 */



function end() {
    module.exports = Object.freeze({
        LANGUAGE_VERSION: "0.0.3",

        utils,
        error,
        inst,
        parser,
        vm
    });
}

const utils  = __webpack_require__(0);
const error  = __webpack_require__(5);
const inst   = __webpack_require__(3);
const parser = __webpack_require__(16);
const vm     = __webpack_require__(19);

end();


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-char / char.js
 */

/**
 * @module char
 */



module.exports = (_core, _prim) => {
    function end() {
        return Object.freeze({
            string,
            satisfy,
            oneOf,
            noneOf,
            char,
            anyChar,
            space,
            spaces,
            newline,
            tab,
            upper,
            lower,
            letter,
            digit,
            alphaNum,
            octDigit,
            hexDigit,
            manyChars,
            manyChars1,
            regexp
        });
    }

    const show             = _core.show;
    const ErrorMessageType = _core.ErrorMessageType;
    const ErrorMessage     = _core.ErrorMessage;
    const ParseError       = _core.ParseError;
    const uncons           = _core.uncons;
    const State            = _core.State;
    const Result           = _core.Result;
    const Parser           = _core.Parser;

    const pure       = _prim.pure;
    const bind       = _prim.bind;
    const label      = _prim.label;
    const reduceMany = _prim.reduceMany;
    const skipMany   = _prim.skipMany;

    /**
     * @function module:char.string
     * @static
     * @param {string} str
     * @returns {AbstractParser}
     */
    function string(str) {
        function eofError(pos) {
            return new ParseError(
                pos,
                [
                    new ErrorMessage(ErrorMessageType.SYSTEM_UNEXPECT, ""),
                    new ErrorMessage(ErrorMessageType.EXPECT, show(str))
                ]
            );
        }
        function expectError(pos, char) {
            return new ParseError(
                pos,
                [
                    new ErrorMessage(ErrorMessageType.SYSTEM_UNEXPECT, show(char)),
                    new ErrorMessage(ErrorMessageType.EXPECT, show(str))
                ]
            );
        }
        return new Parser(state => {
            const len = str.length;
            if (len === 0) {
                return Result.esuc(ParseError.unknown(state.pos), "", state);
            }
            const tabWidth = state.config.tabWidth;
            const unicode  = state.config.unicode;
            let rest = state.input;
            if (unicode) {
                let consumed = false;
                for (const char of str) {
                    const unconsed = uncons(rest, unicode);
                    if (unconsed.empty) {
                        return !consumed
                            ? Result.eerr(eofError(state.pos))
                            : Result.cerr(eofError(state.pos));
                    }
                    else {
                        if (char === unconsed.head) {
                            rest     = unconsed.tail;
                            consumed = true;
                        }
                        else {
                            return !consumed
                                ? Result.eerr(expectError(state.pos, unconsed.head))
                                : Result.cerr(expectError(state.pos, unconsed.head));
                        }
                    }
                }
            }
            else {
                for (let i = 0; i < len; i++) {
                    const unconsed = uncons(rest, unicode);
                    if (unconsed.empty) {
                        return i === 0
                            ? Result.eerr(eofError(state.pos))
                            : Result.cerr(eofError(state.pos));
                    }
                    else {
                        if (str[i] === unconsed.head) {
                            rest = unconsed.tail;
                        }
                        else {
                            return i === 0
                                ? Result.eerr(expectError(state.pos, unconsed.head))
                                : Result.cerr(expectError(state.pos, unconsed.head));
                        }
                    }
                }
            }
            const newPos = state.pos.addString(str, tabWidth, unicode);
            return Result.csuc(
                ParseError.unknown(newPos),
                str,
                new State(state.config, rest, newPos, state.userState)
            );
        });
    }

    /**
     * @function module:char.satisfy
     * @static
     * @param {function} test
     * @returns {AbstractParser}
     */
    function satisfy(test) {
        function systemUnexpectError(pos, str) {
            return new ParseError(
                pos,
                [new ErrorMessage(ErrorMessageType.SYSTEM_UNEXPECT, str)]
            );
        }
        return new Parser(state => {
            const unconsed = uncons(state.input, state.config.unicode);
            if (unconsed.empty) {
                return Result.eerr(systemUnexpectError(state.pos, ""));
            }
            else {
                if (test(unconsed.head, state.config)) {
                    const newPos = state.pos.addChar(unconsed.head, state.config.tabWidth);
                    return Result.csuc(
                        ParseError.unknown(newPos),
                        unconsed.head,
                        new State(state.config, unconsed.tail, newPos, state.userState)
                    );
                }
                else {
                    return Result.eerr(systemUnexpectError(state.pos, show(unconsed.head)));
                }
            }
        });
    }

    /**
     * @function module:char.oneOf
     * @static
     * @param {string} str
     * @returns {AbstractParser}
     */
    function oneOf(str) {
        const cpChars = new Set(str);
        const chars   = new Set();
        for (let i = 0; i < str.length; i++) {
            chars.add(str[i]);
        }
        return satisfy((char, config) => config.unicode ? cpChars.has(char) : chars.has(char));
    }

    /**
     * @function module:char.noneOf
     * @static
     * @param {string} str
     * @returns {AbstractParser}
     */
    function noneOf(str) {
        const cpChars = new Set(str);
        const chars   = new Set();
        for (let i = 0; i < str.length; i++) {
            chars.add(str[i]);
        }
        return satisfy((char, config) => config.unicode ? !cpChars.has(char) : !chars.has(char));
    }

    /**
     * @function module:char.char
     * @static
     * @param {string} expectChar
     * @returns {AbstractParser}
     */
    function char(expectChar) {
        return label(satisfy(char => char === expectChar), show(expectChar));
    }

    /**
     * @constant module:char.anyChar
     * @static
     * @type {AbstractParser}
     */
    const anyChar = satisfy(() => true);

    const spaceChars    = new Set(" \f\n\r\t\v");
    const upperChars    = new Set("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
    const lowerChars    = new Set("abcdefghijklmnopqrstuvwxyz");
    const letterChars   = new Set("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
    const digitChars    = new Set("0123456789");
    const alphaNumChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
    const octDigitChars = new Set("01234567");
    const hexDigitChars = new Set("0123456789ABCDEFabcdef");

    /**
     * @constant module:char.space
     * @static
     * @type {AbstractParser}
     */
    const space = label(satisfy(char => spaceChars.has(char)), "space");

    /**
     * @constant module:char.spaces
     * @static
     * @type {AbstractParser}
     */
    const spaces = label(skipMany(space), "white space");

    /**
     * @constant module:char.newline
     * @static
     * @type {AbstractParser}
     */
    const newline = label(char("\n"), "new-line");

    /**
     * @constant module:char.tab
     * @static
     * @type {AbstractParser}
     */
    const tab = label(char("\t"), "tab");

    /**
     * @constant module:char.upper
     * @static
     * @type {AbstractParser}
     */
    const upper = label(satisfy(char => upperChars.has(char)), "uppercase letter");

    /**
     * @constant module:char.lower
     * @static
     * @type {AbstractParser}
     */
    const lower = label(satisfy(char => lowerChars.has(char)), "lowercase letter");

    /**
     * @constant module:char.letter
     * @static
     * @type {AbstractParser}
     */
    const letter = label(satisfy(char => letterChars.has(char)), "letter");

    /**
     * @constant module:char.digit
     * @static
     * @type {AbstractParser}
     */
    const digit = label(satisfy(char => digitChars.has(char)), "digit");

    /**
     * @constant module:char.alphaNum
     * @static
     * @type {AbstractParser}
     */
    const alphaNum = label(satisfy(char => alphaNumChars.has(char)), "letter or digit");

    /**
     * @constant module:char.octDigit
     * @static
     * @type {AbstractParser}
     */
    const octDigit = label(satisfy(char => octDigitChars.has(char)), "octal digit");

    /**
     * @constant module:char.hexDigit
     * @static
     * @type {AbstractParser}
     */
    const hexDigit = label(satisfy(char => hexDigitChars.has(char)), "hexadecimal digit");

    /**
     * @function module:char.manyChars
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function manyChars(parser) {
        return reduceMany(parser, (accum, char) => accum + char, "");
    }

    /**
     * @function module:char.manyChars1
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function manyChars1(parser) {
        return bind(parser, head => bind(manyChars(parser), tail => pure(head + tail)));
    }

    /**
     * @function module:char.regexp
     * @static
     * @param {RegExp} re
     * @param {number} [groupId = 0]
     * @returns {AbstractParser}
     */
    function regexp(re, groupId) {
        if (groupId === undefined) {
            groupId = 0;
        }
        const flags = (re.ignoreCase ? "i" : "")
            + (re.multiline ? "m" : "")
            + (re.unicode ? "u" : "");
        const anchored = new RegExp(`^(?:${re.source})`, flags);
        const expectStr = show(re);
        return new Parser(state => {
            if (typeof state.input !== "string") {
                throw new Error("`regexp' is only applicable to string input");
            }
            const match = anchored.exec(state.input);
            if (match) {
                const str = match[0];
                const val = match[groupId];
                if (str.length === 0) {
                    return Result.esuc(
                        ParseError.unknown(state.pos),
                        val,
                        state
                    );
                }
                else {
                    const newPos = state.pos.addString(str, state.config.tabWidth, state.config.unicode);
                    return Result.csuc(
                        ParseError.unknown(newPos),
                        val,
                        new State(
                            state.config,
                            state.input.substr(str.length),
                            newPos,
                            state.userState
                        )
                    );
                }
            }
            else {
                return Result.eerr(
                    new ParseError(
                        state.pos,
                        [new ErrorMessage(ErrorMessageType.EXPECT, expectStr)]
                    )
                );
            }
        });
    }

    return end();
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-char / sugar.js
 */

/**
 * @module sugar
 */



module.exports = (_core, _char) => {
    const manyChars  = _char.manyChars;
    const manyChars1 = _char.manyChars1;

    return Object.freeze({
        manyChars: function () {
            return manyChars(this);
        },
        manyChars1: function () {
            return manyChars1(this);
        }
    });
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-combinators / combinators.js
 */

/**
 * @module combinators
 */



module.exports = (_core, _prim) => {
    function end() {
        return Object.freeze({
            choice,
            option,
            optionMaybe,
            optional,
            between,
            many1,
            skipMany1,
            sepBy,
            sepBy1,
            sepEndBy,
            sepEndBy1,
            endBy,
            endBy1,
            count,
            chainl,
            chainl1,
            chainr,
            chainr1,
            anyToken,
            notFollowedBy,
            eof,
            reduceManyTill,
            manyTill,
            skipManyTill
        });
    }

    const show       = _core.show;
    const ParseError = _core.ParseError;
    const Result     = _core.Result;
    const Parser     = _core.Parser;

    const map        = _prim.map;
    const pure       = _prim.pure;
    const bind       = _prim.bind;
    const then       = _prim.then;
    const mzero      = _prim.mzero;
    const mplus      = _prim.mplus;
    const label      = _prim.label;
    const unexpected = _prim.unexpected;
    const tryParse   = _prim.tryParse;
    const many       = _prim.many;
    const skipMany   = _prim.skipMany;
    const tokenPrim  = _prim.tokenPrim;

    /**
     * @function module:combinators.choice
     * @static
     * @param {Array.<AbstractParser>} parsers
     * @returns {AbstractParser}
     */
    function choice(parsers) {
        return parsers.reduceRight((accum, parser) => mplus(parser, accum), mzero);
    }

    /**
     * @function module:combinators.option
     * @static
     * @param {*} val
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function option(val, parser) {
        return mplus(parser, pure(val));
    }

    /**
     * @function module:combinators.optionmaybe
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function optionMaybe(parser) {
        return mplus(
            map(parser, val => ({ empty: false, value: val })),
            map(pure(undefined), () => ({ empty: true }))
        );
    }

    /**
     * @function module:combinators.optional
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function optional(parser) {
        return mplus(then(parser, pure(undefined)), pure(undefined));
    }

    /**
     * @function module:combinators.between
     * @static
     * @param {AbstractParser} open
     * @param {AbstractParser} close
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function between(open, close, parser) {
        return then(open,
            bind(parser, val =>
                then(close,
                    pure(val)
                )
            )
        );
    }

    /**
     * @function module:combinators.many1
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function many1(parser) {
        return bind(parser, head =>
            bind(many(parser), tail =>
                pure([head].concat(tail))
            )
        );
    }

    /**
     * @function module:combinators.skipMany1
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function skipMany1(parser) {
        return then(parser, skipMany(parser));
    }

    /**
     * @function module:combinators.sepBy
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} sep
     * @returns {AbstractParser}
     */
    function sepBy(parser, sep) {
        return mplus(
            sepBy1(parser, sep),
            map(pure(undefined), () => [])
        );
    }

    /**
     * @function module:combinators.sepBy1
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} sep
     * @returns {AbstractParser}
     */
    function sepBy1(parser, sep) {
        return bind(parser, head =>
            bind(many(then(sep, parser)), tail =>
                pure([head].concat(tail))
            )
        );
    }

    /**
     * @function module:combinators.sepEndBy
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} sep
     * @returns {AbstractParser}
     */
    function sepEndBy(parser, sep) {
        return new Parser(state => {
            const accum = [];
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;
            while (true) {
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum.push(res.val);
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        accum.push(res.val);
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.csuc(ParseError.merge(currentErr, res.err), accum, currentState)
                            : Result.esuc(ParseError.merge(currentErr, res.err), accum, currentState);
                    }
                }
                const sepRes = sep.run(currentState);
                if (sepRes.success) {
                    if (sepRes.consumed) {
                        consumed = true;
                        currentState = sepRes.state;
                        currentErr = sepRes.err;
                    }
                    else {
                        currentState = sepRes.state;
                        currentErr = ParseError.merge(currentErr, sepRes.err);
                    }
                }
                else {
                    if (sepRes.consumed) {
                        return sepRes;
                    }
                    else {
                        return consumed
                            ? Result.csuc(ParseError.merge(currentErr, sepRes.err), accum, currentState)
                            : Result.esuc(ParseError.merge(currentErr, sepRes.err), accum, currentState);
                    }
                }
            }
        });
    }

    /**
     * @function module:combinators.sepEndBy1
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} sep
     * @returns {AbstractParser}
     */
    function sepEndBy1(parser, sep) {
        return bind(parser, head =>
            mplus(
                then(sep,
                    bind(sepEndBy(parser, sep), tail =>
                        pure([head].concat(tail))
                    )
                ),
                pure([head])
            )
        );
    }

    /**
     * @function module:combinators.endBy
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} sep
     * @returns {AbstractParser}
     */
    function endBy(parser, sep) {
        return many(
            bind(parser, val =>
                then(sep, pure(val))
            )
        );
    }

    /**
     * @function module:combinators.endBy1
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} sep
     * @returns {AbstractParser}
     */
    function endBy1(parser, sep) {
        return many1(
            bind(parser, val =>
                then(sep, pure(val))
            )
        );
    }

    /**
     * @function module:combinators.count
     * @static
     * @param {number} num
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function count(num, parser) {
        if (num <= 0) {
            return map(pure(undefined), () => []);
        }
        else {
            return new Parser(state => {
                const accum = [];
                let currentState = state;
                let currentErr = ParseError.unknown(state.pos);
                let consumed = false;
                for (let i = 0; i < num; i++) {
                    const res = parser.run(currentState);
                    if (res.success) {
                        if (res.consumed) {
                            consumed = true;
                            accum.push(res.val);
                            currentState = res.state;
                            currentErr = res.err;
                        }
                        else {
                            accum.push(res.val);
                            currentState = res.state;
                            currentErr = ParseError.merge(currentErr, res.err);
                        }
                    }
                    else {
                        if (res.consumed) {
                            return res;
                        }
                        else {
                            return consumed
                                ? Result.cerr(ParseError.merge(currentErr, res.err))
                                : Result.eerr(ParseError.merge(currentErr, res.err));
                        }
                    }
                }
                return consumed
                    ? Result.csuc(currentErr, accum, currentState)
                    : Result.esuc(currentErr, accum, currentState);
            });
        }
    }

    /**
     * @function module:combinators.chainl
     * @static
     * @param {AbstractParser} term
     * @param {AbstractParser} op
     * @param {*} defaultVal
     * @returns {AbstractParser}
     */
    function chainl(term, op, defaultVal) {
        return mplus(
            chainl1(term, op),
            pure(defaultVal)
        );
    }

    /**
     * @function module:combinators.chainl1
     * @static
     * @param {AbstractParser} term
     * @param {AbstractParser} op
     * @returns {AbstractParser}
     */
    function chainl1(term, op) {
        return new Parser(state => {
            let currentVal;
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;

            const headRes = term.run(currentState);
            if (headRes.success) {
                if (headRes.consumed) {
                    consumed = true;
                    currentVal = headRes.val;
                    currentState = headRes.state;
                    currentErr = ParseError.merge(currentErr, headRes.err);
                }
                else {
                    currentVal = headRes.val;
                    currentState = headRes.state;
                    currentErr = ParseError.merge(currentErr, headRes.err);
                }
            }
            else {
                return headRes.consumed
                    ? headRes
                    : Result.eerr(ParseError.merge(currentErr, headRes.err));
            }

            while (true) {
                const initState = currentState;

                const opRes = op.run(currentState);
                let operation;
                if (opRes.success) {
                    if (opRes.consumed) {
                        consumed = true;
                        operation = opRes.val;
                        currentState = opRes.state;
                        currentErr = opRes.err;
                    }
                    else {
                        operation = opRes.val;
                        currentState = opRes.state;
                        currentErr = ParseError.merge(currentErr, opRes.err);
                    }
                }
                else {
                    if (opRes.consumed) {
                        return opRes;
                    }
                    else {
                        return consumed
                            ? Result.csuc(ParseError.merge(currentErr, opRes.err), currentVal, initState)
                            : Result.esuc(ParseError.merge(currentErr, opRes.err), currentVal, initState);
                    }
                }

                const termRes = term.run(currentState);
                if (termRes.success) {
                    if (termRes.consumed) {
                        consumed = true;
                        currentVal = operation(currentVal, termRes.val);
                        currentState = termRes.state;
                        currentErr = termRes.err;
                    }
                    else {
                        currentVal = operation(currentVal, termRes.val);
                        currentState = termRes.state;
                        currentErr = ParseError.merge(currentErr, termRes.err);
                    }
                }
                else {
                    if (termRes.consumed) {
                        return termRes;
                    }
                    else {
                        if (opRes.consumed) {
                            return Result.cerr(ParseError.merge(currentErr, termRes.err));
                        }
                        else {
                            return consumed
                                ? Result.csuc(ParseError.merge(currentErr, termRes.err), currentVal, initState)
                                : Result.esuc(ParseError.merge(currentErr, termRes.err), currentVal, initState);
                        }
                    }
                }
            }
        });
    }

    /**
     * @function module:combinators.chainr
     * @static
     * @param {AbstractParser} term
     * @param {AbstractParser} op
     * @param {*} defaultVal
     * @returns {AbstractParser}
     */
    function chainr(term, op, defaultVal) {
        return mplus(
            chainr1(term, op),
            pure(defaultVal)
        );
    }

    /**
     * @function module:combinators.chainr1
     * @static
     * @param {AbstractParser} term
     * @param {AbstractParser} op
     * @returns {AbstractParser}
     */
    function chainr1(term, op) {
        return new Parser(state => {
            let resultVal;
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;

            const headRes = term.run(currentState);
            if (headRes.success) {
                if (headRes.consumed) {
                    consumed = true;
                    resultVal = headRes.val;
                    currentState = headRes.state;
                    currentErr = headRes.err;
                }
                else {
                    resultVal = headRes.val;
                    currentState = headRes.state;
                    currentErr = ParseError.merge(currentErr, headRes.err);
                }
            }
            else {
                return headRes.consumed
                    ? headRes
                    : Result.eerr(ParseError.merge(currentErr, headRes.err));
            }

            const accum = [];
            const operations = [];
            while (true) {
                const initState = currentState;

                const opRes = op.run(currentState);
                if (opRes.success) {
                    if (opRes.consumed) {
                        consumed = true;
                        operations.push(opRes.val);
                        currentState = opRes.state;
                        currentErr = opRes.err;
                    }
                    else {
                        operations.push(opRes.val);
                        currentState = opRes.state;
                        currentErr = ParseError.merge(currentErr, opRes.err);
                    }
                }
                else {
                    if (opRes.consumed) {
                        return opRes;
                    }
                    else {
                        if (accum.length > 0) {
                            let currentVal = accum[accum.length - 1];
                            for (let i = accum.length - 2; i >= 0; i--) {
                                currentVal = operations[i + 1](accum[i], currentVal);
                            }
                            resultVal = operations[0](resultVal, currentVal);
                        }
                        return consumed
                            ? Result.csuc(ParseError.merge(currentErr, opRes.err), resultVal, initState)
                            : Result.esuc(ParseError.merge(currentErr, opRes.err), resultVal, initState);
                    }
                }

                const termRes = term.run(currentState);
                if (termRes.success) {
                    if (termRes.consumed) {
                        consumed = true;
                        accum.push(termRes.val);
                        currentState = termRes.state;
                        currentErr = termRes.err;
                    }
                    else {
                        accum.push(termRes.val);
                        currentState = termRes.state;
                        currentErr = ParseError.merge(currentErr, termRes.err);
                    }
                }
                else {
                    if (termRes.consumed) {
                        return termRes;
                    }
                    else {
                        if (opRes.consumed) {
                            return Result.cerr(ParseError.merge(currentErr, termRes.err));
                        }
                        else {
                            if (accum.length > 0) {
                                let currentVal = accum[accum.length - 1];
                                for (let i = accum.length - 2; i >= 0; i--) {
                                    currentVal = operations[i + 1](accum[i], currentVal);
                                }
                                resultVal = operations[0](resultVal, currentVal);
                            }
                            return consumed
                                ? Result.csuc(ParseError.merge(currentErr, termRes.err), resultVal, initState)
                                : Result.esuc(ParseError.merge(currentErr, termRes.err), resultVal, initState);
                        }
                    }
                }
            }
        });
    }

    /**
     * @constant module:combinators.anyToken
     * @static
     * @type {AbstractParser}
     */
    const anyToken = tokenPrim(
        token => ({ empty: false, value: token }),
        show,
        pos => pos
    );

    /**
     * @function module:combinators.notFollowedBy
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function notFollowedBy(parser) {
        const modParser = new Parser(state => {
            const res = parser.run(state);
            if (res.consumed && !res.success) {
                return Result.eerr(res.err);
            }
            else if (!res.consumed && res.success) {
                return Result.csuc(res.err, res.val, res.state);
            }
            else {
                return res;
            }
        });
        return tryParse(
            mplus(
                bind(modParser, val => unexpected(show(val))),
                pure(undefined)
            )
        );
    }

    /**
     * @constant module:combinators.eof
     * @static
     * @type {AbstractParser}
     */
    const eof = label(notFollowedBy(anyToken), "end of input");

    /**
     * @function module:combinators.reduceManyTill
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} end
     * @param {function} callback
     * @param {*} initVal
     * @returns {AbstractParser}
     */
    function reduceManyTill(parser, end, callback, initVal) {
        return new Parser(state => {
            let accum = initVal;
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;
            while (true) {
                const endRes = end.run(currentState);
                if (endRes.success) {
                    if (endRes.consumed) {
                        return Result.csuc(endRes.err, accum, endRes.state);
                    }
                    else {
                        return consumed
                            ? Result.csuc(ParseError.merge(currentErr, endRes.err), accum, endRes.state)
                            : Result.esuc(ParseError.merge(currentErr, endRes.err), accum, endRes.state);
                    }
                }
                else {
                    if (endRes.consumed) {
                        return endRes;
                    }
                    else {
                        currentErr = ParseError.merge(currentErr, endRes.err);
                    }
                }

                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum = callback(accum, res.val);
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        accum = callback(accum, res.val);
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }
            }
        });
    }

    /**
     * @function module:combinators.manyTill
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} end
     * @returns {AbstractParser}
     */
    function manyTill(parser, end) {
        return new Parser(state => {
            const accum = [];
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;
            while (true) {
                const endRes = end.run(currentState);
                if (endRes.success) {
                    if (endRes.consumed) {
                        return Result.csuc(endRes.err, accum, endRes.state);
                    }
                    else {
                        return consumed
                            ? Result.csuc(ParseError.merge(currentErr, endRes.err), accum, endRes.state)
                            : Result.esuc(ParseError.merge(currentErr, endRes.err), accum, endRes.state);
                    }
                }
                else {
                    if (endRes.consumed) {
                        return endRes;
                    }
                    else {
                        currentErr = ParseError.merge(currentErr, endRes.err);
                    }
                }

                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum.push(res.val);
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        accum.push(res.val);
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }
            }
        });
    }

    /**
     * @function module:combinators.skipManyTill
     * @static
     * @param {AbstractParser} parser
     * @param {AbstractParser} end
     * @returns {AbstractParser}
     */
    function skipManyTill(parser, end) {
        return reduceManyTill(parser, end, accum => accum, undefined);
    }

    return end();
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-combinators / sugar.js
 */

/**
 * @module sugar
 */



module.exports = (_core, _prim, _combinators) => {
    const isParser = _core.isParser;

    const left     = _prim.left;
    const tryParse = _prim.tryParse;

    const option         = _combinators.option;
    const optionMaybe    = _combinators.optionMaybe;
    const optional       = _combinators.optional;
    const between        = _combinators.between;
    const many1          = _combinators.many1;
    const skipMany1      = _combinators.skipMany1;
    const sepBy          = _combinators.sepBy;
    const sepBy1         = _combinators.sepBy1;
    const sepEndBy       = _combinators.sepEndBy;
    const sepEndBy1      = _combinators.sepEndBy1;
    const endBy          = _combinators.endBy;
    const endBy1         = _combinators.endBy1;
    const count          = _combinators.count;
    const notFollowedBy  = _combinators.notFollowedBy;
    const reduceManyTill = _combinators.reduceManyTill;
    const manyTill       = _combinators.manyTill;
    const skipManyTill   = _combinators.skipManyTill;

    return Object.freeze({
        option: function (val) {
            return option(this, val);
        },
        optionMaybe: function () {
            return optionMaybe(this);
        },
        optional: function () {
            return optional(this);
        },
        between: function (open, close) {
            return between(open, close, this);
        },
        many1: function () {
            return many1(this);
        },
        skipMany1: function (parser) {
            return isParser(parser)
                ? left(this, skipMany1(parser))
                : skipMany1(this);
        },
        sepBy: function (sep) {
            return sepBy(this, sep);
        },
        sepBy1: function (sep) {
            return sepBy1(this, sep);
        },
        sepEndBy: function (sep) {
            return sepEndBy(this, sep);
        },
        sepEndBy1: function (sep) {
            return sepEndBy1(this, sep);
        },
        endBy: function (sep) {
            return endBy(this, sep);
        },
        endBy1: function (sep) {
            return endBy1(this, sep);
        },
        count: function (num) {
            return count(num, this);
        },
        notFollowedBy: function (parser) {
            return isParser(parser)
                ? tryParse(left(this, notFollowedBy(parser)))
                : notFollowedBy(this);
        },
        reduceManyTill: function (end, callback, initVal) {
            return reduceManyTill(this, end, callback, initVal);
        },
        manyTill: function (end) {
            return manyTill(this, end);
        },
        skipManyTill: function (parser, end) {
            return isParser(end)
                ? left(this, skipManyTill(parser, end))
                : skipManyTill(this, parser);
        }
    });
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-core
 */



module.exports = () => {
    const _utils  = __webpack_require__(30)();
    const _pos    = __webpack_require__(28)();
    const _error  = __webpack_require__(26)(_pos);
    const _stream = __webpack_require__(29)(_utils);
    const _parser = __webpack_require__(27)(_pos, _error);

    return Object.freeze({
        show        : _utils.show,
        unconsString: _utils.unconsString,

        SourcePos: _pos.SourcePos,

        ErrorMessageType  : _error.ErrorMessageType,
        ErrorMessage      : _error.ErrorMessage,
        AbstractParseError: _error.AbstractParseError,
        ParseError        : _error.ParseError,
        LazyParseError    : _error.LazyParseError,

        uncons: _stream.uncons,

        Config        : _parser.Config,
        State         : _parser.State,
        Result        : _parser.Result,
        AbstractParser: _parser.AbstractParser,
        Parser        : _parser.Parser,
        LazyParser    : _parser.LazyParser,
        lazy          : _parser.lazy,
        parse         : _parser.parse,
        isParser      : _parser.isParser,
        assertParser  : _parser.assertParser,
        extendParser  : _parser.extendParser
    });
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-core / error.js
 */

/**
 * @module error
 */



module.exports = _pos => {
    function end() {
        return Object.freeze({
            ErrorMessageType,
            ErrorMessage,
            AbstractParseError,
            ParseError,
            LazyParseError,
            _internal: {
                cleanMessageStrings,
                joinWithCommasOr,
                joinMessageStrings
            }
        });
    }

    const SourcePos = _pos.SourcePos;

    /**
     * @constant {Object} module:error.ErrorMessageType
     * @description The `ErrorMessageType` object has string constants, each describes a type of error message:
     * - `ErrorMessageType.SYSTEM_UNEXPECT = "systemUnexpect"`
     * - `ErrorMessageType.UNEXPECT = "unexpect"`
     * - `ErrorMessageType.EXPECT = "expect"`
     * - `ErrorMessageType.MESSAGE = "mesage"`
     * @static
     */
    const ErrorMessageType = Object.freeze({
        SYSTEM_UNEXPECT: "systemUnexpect",
        UNEXPECT       : "unexpect",
        EXPECT         : "expect",
        MESSAGE        : "message"
    });

    /**
     * An instance of the `ErrorMessage` class represents a specific type error message.
     * @static
     */
    class ErrorMessage {
        /**
         * Creates a new `ErrorMessage` instance.
         * @param {string} type One of the constant of `ErrorMessageType`.
         * @param {string} msgStr Message string.
         */
        constructor(type, msgStr) {
            this._type   = type;
            this._msgStr = msgStr;
        }

        /**
         * Checks if two messages are the same.
         * @param {module:error.ErrorMessage} msgA An {@link module:error.ErrorMessage} object.
         * @param {module:error.ErrorMessage} msgB An {@link module:error.ErrorMessage} object.
         * @returns {boolean} `true` if two messages are the same.
         */
        static equal(msgA, msgB) {
            return msgA.type === msgB.type
                && msgA.msgStr === msgB.msgStr;
        }

        /**
         * Returns pretty-printed string of the error messages.
         * @param {Array.<ErrorMessage>} msgs An array of {@link module:error.ErrorMessage} objects.
         * @returns {string} Printed string.
         * @throws {Error} A message has unknown type.
         */
        static messagesToString(msgs) {
            if (msgs.length === 0) {
                return "unknown parse error";
            }
            const systemUnexpects = [];
            const unexpects       = [];
            const expects         = [];
            const defaultMessages = [];
            for (const msg of msgs) {
                switch (msg.type) {
                case ErrorMessageType.SYSTEM_UNEXPECT:
                    systemUnexpects.push(msg.msgStr);
                    break;
                case ErrorMessageType.UNEXPECT:
                    unexpects.push(msg.msgStr);
                    break;
                case ErrorMessageType.EXPECT:
                    expects.push(msg.msgStr);
                    break;
                case ErrorMessageType.MESSAGE:
                    defaultMessages.push(msg.msgStr);
                    break;
                default:
                    throw new Error("unknown message type: " + msg.type);
                }
            }
            const msgStrs = [
                unexpects.length === 0 && systemUnexpects.length !== 0
                    ? systemUnexpects[0] === ""
                        ? "unexpected end of input"
                        : "unexpected " + systemUnexpects[0]
                    : "",
                joinMessageStrings(cleanMessageStrings(unexpects), "unexpected"),
                joinMessageStrings(cleanMessageStrings(expects), "expecting"),
                joinMessageStrings(cleanMessageStrings(defaultMessages))
            ];
            return cleanMessageStrings(msgStrs).join("\n");
        }

        /**
         * Checks if two arrays describe the same error messages.
         * @param {Array.<module:error.ErrorMessage>} msgsA An array of {@link module:error.ErrorMessage} objects.
         * @param {Array.<module:error.ErrorMessage>} msgsB An array of {@link module:error.ErrorMessage} objects.
         * @returns {boolean} `true` if two arrays describe the same error messages with the same order.
         */
        static messagesEqual(msgsA, msgsB) {
            if (msgsA.length !== msgsB.length) {
                return false;
            }
            const len = msgsA.length;
            for (let i = 0; i < len; i++) {
                if (!ErrorMessage.equal(msgsA[i], msgsB[i])) {
                    return false;
                }
            }
            return true;
        }

        /**
         * @readonly
         * @type {string}
         */
        get type() {
            return this._type;
        }

        /**
         * @readonly
         * @type {string}
         */
        get msgStr() {
            return this._msgStr;
        }
    }

    /**
     * @function module:error.cleanMessageStrings
     * @description Cleans array of message strings by removing empty and duplicate elements.
     * @private
     * @static
     * @param {Array.<string>} msgStrs An array of message strings.
     * @returns {Array.<strings>} Cleaned array.
     */
    function cleanMessageStrings(msgStrs) {
        return msgStrs.filter((msgStr, i) => msgStr !== "" && msgStrs.indexOf(msgStr) === i);
    }

    /**
     * @function module:error.joinWithCommasOr
     * @description Joins strings with commas (,) and "or".
     * @private
     * @static
     * @param {Array.<string>} msgStrs An array of message strings.
     * @returns {string} Joined string.
     */
    function joinWithCommasOr(msgStrs) {
        return msgStrs.length <= 2
            ? msgStrs.join(" or ")
            : msgStrs.slice(0, msgStrs.length - 1).join(", ") + " or " + msgStrs[msgStrs.length - 1];
    }

    /**
     * @function module:error.joinMessageStrings
     * @description Joins message strings with the specified description.
     * @private
     * @static
     * @param {Array.<string>} msgStrs An array of message strings.
     * @param {string} [desc = ""] Short description of the messages.
     * @returns {string} Joined messages.
     */
    function joinMessageStrings(msgStrs, desc) {
        if (typeof desc === "undefined") {
            desc = "";
        }
        return msgStrs.length === 0
            ? ""
            : (desc === "" ? "" : desc + " ") + joinWithCommasOr(msgStrs);
    }

    /**
     * The `AbstractParseError` class is inherited by the concrete parse error classes.
     * This class is abstract and you cannot create `AbstractParseError` instance directly.
     * @static
     */
    class AbstractParseError {
        /**
         * You cannot create `AbstractParseError` instance directly.
         * @throws {Error}
         */
        constructor() {
            if (this.constructor === AbstractParseError) {
                throw new Error("cannot create AbstractParseError object");
            }
        }

        /**
         * Not implemented.
         * @readonly
         * @type {module:pos.SourcePos}
         * @throws {Error}
         */
        get pos() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @readonly
         * @type {Array.<module:error.ErrorMessage>}
         * @throws {Error}
         */
        get msgs() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @returns {string}
         * @throws {Error}
         */
        toString() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @returns {boolean}
         * @throws {Error}
         */
        isUnknown() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @param {module:pos.SourcePos} pos
         * @returns {module:error.AbstractParseError}
         * @throws {Error}
         */
        setPosition() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @param {Array.<module:error.ErrorMessage>} msgs
         * @returns {module:error.AbstractParseError}
         * @throws {Error}
         */
        setMessages() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @param {Array.<module:error.ErrorMessage>} msgs
         * @returns {module:error.AbstractParseError}
         * @throws {Error}
         */
        addMessages() {
            throw new Error("not implemented");
        }

        /**
         * Not implemented.
         * @param {string} type
         * @param {Array.<string>} msgStrs
         * @returns {module:error.AbstractParseError}
         * @throws {Error}
         */
        setSpecificTypeMessages() {
            throw new Error("not implemented");
        }
    }

    /**
     * @static
     * @extends {module:error.AbstractParseError}
     */
    class ParseError extends AbstractParseError {
        /**
         * Creates a new `ParseError` instance.
         * @param {module:pos.SourcePos} pos
         * @param {Array.<module:error.ErrorMessage>} msgs
         */
        constructor(pos, msgs) {
            super();
            this._pos  = pos;
            this._msgs = msgs;
        }

        /**
         * @param {module:pos.SourcePos} pos
         * @returns {module:error.ParseError}
         */
        static unknown(pos) {
            return new ParseError(pos, []);
        }

        /**
         * @param {module:error.AbstractParseError} errA
         * @param {module:error.AbstractParseError} errB
         * @returns {boolean}
         */
        static equal(errA, errB) {
            return SourcePos.equal(errA.pos, errB.pos)
                && ErrorMessage.messagesEqual(errA.msgs, errB.msgs);
        }

        /**
         * @param {module:error.AbstractParseError} errA
         * @param {module:error.AbstractParseError} errB
         * @returns {module:error.AbstractParseError}
         */
        static merge(errA, errB) {
            return new LazyParseError(() => {
                const cmp = SourcePos.compare(errA.pos, errB.pos);
                return errB.isUnknown() && !errA.isUnknown() ? errA
                     : errA.isUnknown() && !errB.isUnknown() ? errB
                     : cmp > 0                               ? errA
                     : cmp < 0                               ? errB
                                                             : errA.addMessages(errB.msgs);
            });
        }

        /**
         * @readonly
         * @type {module:pos.SourcePos}
         */
        get pos() {
            return this._pos;
        }

        /**
         * @readonly
         * @type {Array.<module:error.ErrorMessage>}
         */
        get msgs() {
            return this._msgs;
        }

        /**
         * @returns {string}
         */
        toString() {
            return `${this.pos}:\n${ErrorMessage.messagesToString(this.msgs)}`;
        }

        /**
         * @returns {boolean}
         */
        isUnknown() {
            return this.msgs.length === 0;
        }

        /**
         * @param {module:pos.SourcePos} pos
         * @returns {module:error.AbstractParseError}
         */
        setPosition(pos) {
            return new ParseError(pos, this.msgs);
        }

        /**
         * @param {Array.<module:error.ErrorMessage>} msgs
         * @returns {module:error.AbstractParseError}
         */
        setMessages(msgs) {
            return new ParseError(this.pos, msgs);
        }

        /**
         * @param {Array.<module:error.ErrorMessage>} msgs
         * @returns {module:error.AbstractParseError}
         */
        addMessages(msgs) {
            return new LazyParseError(() => new ParseError(this.pos, this.msgs.concat(msgs)));
        }

        /**
         * @param {string} type
         * @param {Array.<string>} msgStrs
         * @returns {module:error.AbstractParseError}
         */
        setSpecificTypeMessages(type, msgStrs) {
            return new LazyParseError(() => new ParseError(
                this.pos,
                this.msgs.filter(msg => msg.type !== type)
                    .concat(msgStrs.map(msgStr => new ErrorMessage(type, msgStr)))
            ));
        }
    }

    /**
     * @static
     * @extends {module:error.AbstractParseError}
     */
    class LazyParseError extends AbstractParseError {
        /**
         * Creates a new `LazyParseError` instance.
         * @param {function} thunk A function that returns an {@link module:error.AbstractParseError} object.
         */
        constructor(thunk) {
            super();
            this._thunk = thunk;
            this._cache = undefined;
        }

        /**
         * @returns {module:error.ParseError}
         * @throws {TypeError} Invalid thunk (not a function) found while evaluation.
         * @throws {TypeError} The final evaluation result is not a {@link module:error.ParseError} object.
         */
        eval() {
            if (this._cache) {
                return this._cache;
            }
            const lazyErrs = [];
            let err = this;
            while (err instanceof LazyParseError) {
                if (err._cache) {
                    err = err._cache;
                }
                else {
                    lazyErrs.push(err);
                    if (typeof err._thunk !== "function") {
                        throw new TypeError("thunk is not a function");
                    }
                    err = err._thunk.call(undefined);
                }
            }
            if (!(err instanceof ParseError)) {
                throw new TypeError("evaluation result is not a ParseError obejct");
            }
            for (const lazyErr of lazyErrs) {
                lazyErr._cache = err;
            }
            return err;
        }

        /**
         * @readonly
         * @type {module:pos.SourcePos}
         */
        get pos() {
            return this.eval().pos;
        }

        /**
         * @readonly
         * @type {Array.<module:error.ErrorMessage>}
         */
        get msgs() {
            return this.eval().msgs;
        }

        /**
         * @returns {string}
         */
        toString() {
            return this.eval().toString();
        }

        /**
         * @returns {boolean}
         */
        isUnknown() {
            return this.eval().isUnknown();
        }

        /**
         * @param {module:pos.SourcePos} pos
         * @returns {module:error.AbstractParseError}
         */
        setPosition(pos) {
            return new LazyParseError(() => this.eval().setPosition(pos));
        }

        /**
         * @param {Array.<module:error.ErrorMessage>} msgs
         * @returns {module:error.AbstractParseError}
         */
        setMessages(msgs) {
            return new LazyParseError(() => this.eval().setMessages(msgs));
        }

        /**
         * @param {Array.<module:error.ErrorMessage>} msgs
         * @returns {module:error.AbstractParseError}
         */
        addMessages(msgs) {
            return new LazyParseError(() => this.eval().addMessages(msgs));
        }

        /**
         * @param {string} type
         * @param {Array.<string>} msgStrs
         * @returns {module:error.AbstractParseError}
         */
        setSpecificTypeMessages(type, msgStrs) {
            return new LazyParseError(() => this.eval().setSpecificTypeMessages(type, msgStrs));
        }
    }

    return end();
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-core / parser.js
 */

/**
 * @module parser
 */



module.exports = (_pos, _error) => {
    function end() {
        return Object.freeze({
            Config,
            State,
            Result,
            AbstractParser,
            Parser,
            LazyParser,
            lazy,
            parse,
            isParser,
            assertParser,
            extendParser
        });
    }

    const SourcePos = _pos.SourcePos;

    const ParseError = _error.ParseError;

    /**
     * The `Config` class represents parser configuration.
     * @static
     */
    class Config {
        /**
         * Creates a new `Config` instance.
         * @param {Object} [opts = {}] An object containing configuration options.
         * Available configurations are listed below:
         * <table>
         * <tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr>
         * <tr><td>tabWidth</td><td>number</td><td>8</td><td>Positive integer specifying tab width.</td></tr>
         * <tr><td>unicode</td><td>boolean</td><td>false</td><td>Enables unicode features.
         * If `true`, characters are treated as code points.
         * (For instance, `"\uD83C\uDF63"` is 2 characters (code units) in non-unicode mode,
         * while it is 1 character (code point) in unicode mode.)
         * </td></tr>
         * </table>
         */
        constructor(opts) {
            if (opts === undefined) {
                opts = {};
            }
            this._tabWidth     = opts.tabWidth === undefined ? 8 : opts.tabWidth;
            this._unicode = opts.unicode === undefined ? false : opts.unicode;
        }

        /**
         * Checks if two configs are equal.
         * @param {module:parser.Config} configA
         * @param {module:parser.Config} configB
         * @returns {boolean}
         */
        static equal(configA, configB) {
            return configA.tabWidth === configB.tabWidth
                && configA.unicode === configB.unicode;
        }

        /**
         * @readonly
         * @type {number}
         */
        get tabWidth() {
            return this._tabWidth;
        }

        /**
         * @readonly
         * @type {boolean}
         */
        get unicode() {
            return this._unicode;
        }
    }

    /**
     * An instance of the `State` class describes state at some point in parsing.
     * @static
     */
    class State {
        /**
         * Creates a new `State` instance.
         * @param {module:parser.Config} config Configuration of current parsing.
         * @param {(string|Array|module:stream.IStream)} input Current input.
         * @param {module:pos.SourcePos} pos Current position.
         * @param {*} [userState = undefined] Additional user-defined state for advanced use.
         */
        constructor(config, input, pos, userState) {
            this._config    = config;
            this._input     = input;
            this._pos       = pos;
            this._userState = userState;
        }

        /**
         * Checks if two states are equal.
         * @param {module:parser.State} stateA
         * @param {module:parser.State} stateB
         * @param {(function|undefined)} [inputEqual = undefined]
         * @param {(function|undefined)} [userStateEqual = undefined]
         * @returns {boolean}
         */
        static equal(stateA, stateB, inputEqual, userStateEqual) {
            return Config.equal(stateA.config, stateB.config)
                && (inputEqual === undefined
                    ? stateA.input === stateB.input
                    : inputEqual(stateA.input, stateB.input))
                && SourcePos.equal(stateA.pos, stateB.pos)
                && (userStateEqual === undefined
                    ? stateA.userState === stateB.userState
                    : userStateEqual(stateA.userState, stateB.userState));
        }

        /**
         * @readonly
         * @type {module:parser.Config}
         */
        get config() {
            return this._config;
        }

        /**
         * @readonly
         * @type {(string|Array|module:stream.IStream)}
         */
        get input() {
            return this._input;
        }

        /**
         * @readonly
         * @type {module:pos.SourcePos}
         */
        get pos() {
            return this._pos;
        }

        /**
         * @readonly
         * @type {*}
         */
        get userState() {
            return this._userState;
        }

        /**
         * @param {module:parser.Config} config
         * @returns {module:parser.State}
         */
        setConfig(config) {
            return new State(config, this.input, this.pos, this.userState);
        }

        /**
         * @param {(string|Array|module:stream.IStream)} input
         * @returns {module:parser.State}
         */
        setInput(input) {
            return new State(this.config, input, this.pos, this.userState);
        }

        /**
         * @param {module:pos.SourcePos} pos
         * @returns {module:parser.State}
         */
        setPosition(pos) {
            return new State(this.config, this.input, pos, this.userState);
        }

        /**
         * @param {*} userState
         * @returns {module:parser.State}
         */
        setUserState(userState) {
            return new State(this.config, this.input, this.pos, userState);
        }
    }

    /**
     * The `Result` class represents a result of parsing.
     * @static
     */
    class Result {
        /**
         * Creates a new `Result` instance.
         * @param {boolean} consumed Indicates the parser consumed input or not.
         * @param {boolean} success Indicates parsing succeeded or not.
         * If `true`, `val` and `state` must be specified.
         * @param {module:error.AbstractParseError} err Parse error object.
         * @param {*} [val = undefined] Obtained value.
         * @param {(module:parser.State|undefined)} [state = undefined] Next state.
         */
        constructor(consumed, success, err, val, state) {
            this._consumed = consumed;
            this._success  = success;
            this._err      = err;
            this._val      = val;
            this._state    = state;
        }

        /**
         * Checks if two results are equal.
         * The properties `val` and `state` are compared only when both results are success.
         * @param {module:parser.Result} resA
         * @param {module:parser.Result} resB
         * @param {(function|undefined)} valEqual
         * @param {(function|undefined)} inputEqual
         * @param {(function|undefined)} userStateEqual
         * @returns {boolean}
         */
        static equal(resA, resB, valEqual, inputEqual, userStateEqual) {
            if (resA.success && resB.success) {
                return resA.consumed === resB.consumed
                    && (valEqual === undefined
                        ? resA.val === resB.val
                        : valEqual(resA.val, resB.val))
                    && State.equal(resA.state, resB.state, inputEqual, userStateEqual)
                    && ParseError.equal(resA.err, resB.err);
            }
            else {
                return resA.success === resB.success
                    && resA.consumed === resB.consumed
                    && ParseError.equal(resA.err, resB.err);
            }
        }

        /**
         * Returns a consumed success result object.
         * @param {module:error.AbstractParseError} err
         * @param {*} val
         * @param {module:parser.State} state
         * @returns {module:parser.Result}
         */
        static csuc(err, val, state) {
            return new Result(true, true, err, val, state);
        }

        /**
         * Returns a consumed failure result object.
         * @param {module:error.AbstractParseError} err
         * @returns {module:parser.Result}
         */
        static cerr(err) {
            return new Result(true, false, err);
        }

        /**
         * Returns an empty success result object.
         * @param {module:error.AbstractParseError} err
         * @param {*} val
         * @param {module:parser.State} state
         * @returns {module:parser.Result}
         */
        static esuc(err, val, state) {
            return new Result(false, true, err, val, state);
        }

        /**
         * Returns an empty failure result object.
         * @param {module:error.AbstractParseError} err
         * @returns {module:parser.Result}
         */
        static eerr(err) {
            return new Result(false, false, err);
        }

        /**
         * @readonly
         * @type {boolean}
         */
        get consumed() {
            return this._consumed;
        }

        /**
         * @readonly
         * @type {boolean}
         */
        get success() {
            return this._success;
        }

        /**
         * @readonly
         * @type {module:error.AbstractParseError}
         */
        get err() {
            return this._err;
        }

        /**
         * @readonly
         * @type {*}
         */
        get val() {
            return this._val;
        }

        /**
         * @readonly
         * @type {module:parser.State}
         */
        get state() {
            return this._state;
        }
    }

    /**
     * The `AbstractParser` class is inherited by the concrete parser classes,
     * and is used for extending all the parser classes.
     * This class is abstract and you cannot create `AbstractParser` instance directly.
     * @static
     */
    class AbstractParser {
        /**
         * You cannot create `AbstractParser` instance directly.
         * @throws {Error}
         */
        constructor() {
            if (this.constructor === AbstractParser) {
                throw new Error("cannot create AbstractParser object");
            }
        }

        /**
         * Not implemented.
         * @returns {module:parser.Result}
         * @throws {Error}
         */
        run() {
            throw new Error("not implemented");
        }

        /**
         * @param {string} name
         * @param {(string | Array | module:stream.IStream)} input
         * @param {*} [userState = undefined]
         * @param {Object} [opts = {}]
         * @returns {Object}
         */
        parse(name, input, userState, opts) {
            return parse(this, name, input, userState, opts);
        }
    }

    /**
     * The `Parser` class is just a wrapper of parser function.
     * @static
     * @extends {module:parser.AbstractParser}
     */
    class Parser extends AbstractParser {
        /**
         * Creates a new `Parser` object.
         * @param {function} func Parser function, which must take a {@link module:parser.State} object as its argument
         * and return a {@link module:parser.Result} object.
         */
        constructor(func) {
            super();
            this._func = func;
        }

        /**
         * @param {module:parser.State} state
         * @returns {module:parser.Result}
         */
        run(state) {
            return this._func.call(undefined, state);
        }
    }

    /**
     * The `LazyParser` class is a lazy version of the {@link:module.Parser} class.
     * @static
     * @extends {module:parser.AbstractParser}
     */
    class LazyParser extends AbstractParser {
        /**
         * Creates a new `LazyParser` object.
         * @param {function} thunk A function, which must return an {@link module:parser.AbstractParser} object.
         */
        constructor(thunk) {
            super();
            this._thunk = thunk;
            this._cache = undefined;
        }

        /**
         * Evaluates the thunk.
         * @returns {module:parser.Parser}
         * @throws {TypeError} Invalid thunk (not a function) found while evaluation.
         * @throws {TypeError} The final evaluation result is not a {@link module:error.ParseError} object.
         */
        eval() {
            if (this._cache) {
                return this._cache;
            }
            const lazyParsers = [];
            let parser = this;
            while (parser instanceof LazyParser) {
                if (parser._cache) {
                    parser = parser._cache;
                }
                else {
                    lazyParsers.push(parser);
                    if (typeof parser._thunk !== "function") {
                        throw new TypeError("thunk is not a function");
                    }
                    parser = parser._thunk.call(undefined);
                }
            }
            if (!(parser instanceof Parser)) {
                throw new TypeError("evaluation result is not a Parser object");
            }
            for (const lazyParser of lazyParsers) {
                lazyParser._cache = parser;
            }
            return parser;
        }

        /**
         * @param {module:parser.State} state
         * @returns {module:parser.Result}
         */
        run(state) {
            return this.eval().run(state);
        }
    }

    /**
     * @function module:parser.lazy
     * @description Shorthand for `new LazyParser()`.
     * @static
     * @param {function} thunk
     * @returns {module:parser.LazyParser}
     */
    function lazy(thunk) {
        return new LazyParser(thunk);
    }

    /**
     * @function module:parser.parse
     * @static
     * @param {module:parser.AbstractParser} parser
     * @param {string} name
     * @param {(string | Array | module:stream.IStream)} input
     * @param {*} [userState = undefined]
     * @param {Object} [opts = {}]
     * @returns {Object}
     */
    function parse(parser, name, input, userState, opts) {
        if (opts === undefined) {
            opts = {};
        }
        const state = new State(new Config(opts), input, SourcePos.init(name), userState);
        const res   = parser.run(state);
        return res.success
            ? { success: true, value: res.val }
            : { success: false, error: res.err };
    }

    /**
     * @function module:parser.isParser
     * @static
     * @param {*} val
     * @return {boolean}
     */
    function isParser(val) {
        return val instanceof AbstractParser;
    }

    /**
     * @function module:parser.assertParser
     * @static
     * @param {*} val
     * @return {undefined}
     * @throws {Error} Not a parser.
     */
    function assertParser(val) {
        if (!isParser(val)) {
            throw new Error("not a parser");
        }
    }

    /**
     * @function module:parser.extendParser
     * @static
     * @param {Object} extensions
     * @returns {undefined}
     */
    function extendParser(extensions) {
        const descs = {};
        for (const key of Object.keys(extensions)) {
            descs[key] = {
                value       : extensions[key],
                writable    : true,
                configurable: true,
                enumerable  : false
            };
        }
        Object.defineProperties(AbstractParser.prototype, descs);
    }

    return end();
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-core / pos.js
 */

/**
 * @module pos
 */



module.exports = () => {
    function end() {
        return Object.freeze({
            SourcePos
        });
    }

    /**
     * An instance of the `SourcePos` class represents a specific position in the source.
     * @static
     */
    class SourcePos {
        /**
         * Creates a new `SourcePos` instance.
         * @param {string} name Name of the source.
         * @param {number} line Line in the source.
         * @param {number} column Column in the source.
         */
        constructor(name, line, column) {
            this._name   = name;
            this._line   = line;
            this._column = column;
        }

        /**
         * Creates a new `SourcePos` instance initialized with `line = 1` and `column = 1`.
         * @param {string} name Name of the source.
         * @returns {module:pos.SourcePos} New `SourcePos` instance.
         */
        static init(name) {
            return new SourcePos(name, 1, 1);
        }

        /**
         * Checks if two `SourcePos` instances describe the same position.
         * @param {module:pos.SourcePos} posA
         * @param {module:pos.SourcePos} posB
         * @returns {boolean} `true` if two `SoucePos` instances describe the same position.
         */
        static equal(posA, posB) {
            return posA.name   === posB.name
                && posA.line   === posB.line
                && posA.column === posB.column;
        }

        /**
         * Compares two `SourcePos` instances.
         * @param {module:pos.SourcePos} posA
         * @param {module:pos.SourcePos} posB
         * @returns {number} Negative if `posA` describes a position ahead of `posB`.
         * Positive if `posA` describes a position behind `posB`.
         * Zero if `posA` and `posB` describe the same.
         */
        static compare(posA, posB) {
            return posA.name   < posB.name   ? -1
                 : posA.name   > posB.name   ? 1
                 : posA.line   < posB.line   ? -1
                 : posA.line   > posB.line   ? 1
                 : posA.column < posB.column ? -1
                 : posA.column > posB.column ? 1
                                             : 0;
        }

        /**
         * @readonly
         * @type {string}
         */
        get name() {
            return this._name;
        }

        /**
         * @readonly
         * @type {number}
         */
        get line() {
            return this._line;
        }

        /**
         * @readonly
         * @type {number}
         */
        get column() {
            return this._column;
        }

        /**
         * Returns the string representation of the position.
         * @returns {string} The string representation of the position.
         */
        toString() {
            return (this.name === "" ? "" : `"${this.name}"`)
                + `(line ${this.line}, column ${this.column})`;
        }

        /**
         * Creates a new copy of the instance with `name` set to the specified value.
         * @param {string} name
         * @returns {module:pos.SourcePos} Copy of the instance.
         */
        setName(name) {
            return new SourcePos(name, this.line, this.column);
        }

        /**
         * Creates a new copy of the instance with `line` set to the specified value.
         * @param {number} line
         * @returns {module:pos.SourcePos} Copy of the instance.
         */
        setLine(line) {
            return new SourcePos(this.name, line, this.column);
        }

        /**
         * Creates a new copy of the instance with `column` set to the specified value.
         * @param {number} column
         * @returns {module:pos.SourcePos} Copy of the instance.
         */
        setColumn(column) {
            return new SourcePos(this.name, this.line, column);
        }

        /**
         * @param {string} char
         * @param {number} tabWidth
         * @returns {module:pos.SourcePos}
         */
        addChar(char, tabWidth) {
            // For this case
            // - `if` is faster than `switch`
            // - comparing strings is faster than character codes
            if (char === "") {
                return new SourcePos(this.name, this.line, this.column);
            }
            else if (char === "\n") {
                return new SourcePos(this.name, this.line + 1, 1);
            }
            else if (char === "\t") {
                return new SourcePos(this.name, this.line, this.column + tabWidth - (this.column - 1) % tabWidth);
            }
            else {
                return new SourcePos(this.name, this.line, this.column + 1);
            }
        }

        /**
         * @param {string} str
         * @param {number} tabWidth
         * @param {boolean} unicode If `true` specified, the characters are counted in units of code points.
         * @returns {module:pos.SourcePos}
         */
        addString(str, tabWidth, unicode) {
            // For this case
            // - `switch` is faster than `if`
            // - comparing character codes is faster than strings
            let line   = this.line;
            let column = this.column;
            if (unicode) {
                for (const char of str) {
                    switch (char.charCodeAt(0)) {
                    case 10: // "\n"
                        line  += 1;
                        column = 1;
                        break;
                    case 9: // "\t"
                        column += tabWidth - (column - 1) % tabWidth;
                        break;
                    default:
                        column += 1;
                    }
                }
            }
            else {
                const len = str.length;
                for (let i = 0; i < len; i++) {
                    switch (str.charCodeAt(i)) {
                    case 10: // "\n"
                        line  += 1;
                        column = 1;
                        break;
                    case 9: // "\t"
                        column += tabWidth - (column - 1) % tabWidth;
                        break;
                    default:
                        column += 1;
                    }
                }
            }
            return new SourcePos(this.name, line, column);
        }
    }

    return end();
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-core / stream.js
 */

/**
 * @module stream
 */



module.exports = _utils => {
    function end() {
        return Object.freeze({
            uncons,
            ArrayStream
        });
    }

    const unconsString = _utils.unconsString;

    /**
     * @interface IStream
     * @description The `IStream` interface abstracts stream objects.
     * User-defined streams must implement this interface.
     * @static
     */
    /**
     * @method module:stream.IStream#uncons
     * @description Reads the stream.
     * It must return an object that satisfies these requirements:
     * <table>
     * <tr><th>Property</th><th>Type</th><th>Description</th></tr>
     * <tr><td>`empty`</td><td>boolean</td><td>Indicates the stream is empty or not.
     * If not empty, the object must have `head` and `tail` properties.</td></tr>
     * <tr><td>`head`</td><td></td><td>The head of the stream.</td></tr>
     * <tr><td>`tail`</td><td>{@link module:stream.IStream}</td><td>The tail (rest) of the stream.</td></tr>
     * </table>
     * @param {boolean} unicode If `true` specified, string-like stream should enable unicode features.
     * @returns {Object} An object that have properties describes above.
     */

    /**
     * @function module:stream.uncons
     * @description Reads input.
     * A result object should contain the following properties.
     * <table>
     * <tr><th>Property</th><th>Type</th><th>Description</th></tr>
     * <tr><td>`empty`</td><td>boolean</td><td>Indicates the input is empty or not.
     * If not empty, the object have `head` and `tail` properties.</td></tr>
     * <tr><td>`head`</td><td></td><td>The head of the input.</td></tr>
     * <tr><td>`tail`</td><td>string | Array | {@link module:stream.IStream}</td>
     * <td>The tail (rest) of the input.</td></tr>
     * </table>
     * @static
     * @param {(string|Array|module:stream.IStream)} input A string, an array,
     * or an {@link module:stream.IStream} object.
     * @param {boolean} unicode For string input, if `true` specified characters are unconsed in code point unit.
     * For string-like stream, if `true` specified it would enable unicode features
     * through {@link module:stream.IStream#uncons} method.
     * @returns {Object} An object that have properties describes above.
     * @throws {TypeError} `input` is not a string nor an array,
     * or object does not implement the {@link module:stream.IStream} interface.
     */
    function uncons(input, unicode) {
        if (typeof input === "string") {
            return unconsString(input, unicode);
        }
        else if (Array.isArray(input)) {
            return input.length === 0
                ? { empty: true }
                : { empty: false, head: input[0], tail: input.slice(1) };
        }
        else if (typeof input === "object" && input !== null) {
            if (typeof input.uncons === "function") {
                return input.uncons(unicode);
            }
            else {
                throw new TypeError("not a stream");
            }
        }
        else {
            throw new TypeError("not a stream");
        }
    }

    /**
     * The `ArrayStream` class provide more efficient stream of arrays.
     * @static
     * @implements {module:stream.IStream}
     */
    class ArrayStream {
        /**
         * Creates a new `ArrayStream` instance.
         * @param {Array} arr An array object.
         * @param {number} index Current index.
         */
        constructor(arr, index) {
            this._arr   = arr;
            this._index = index;
        }

        /**
         * @readonly
         * @type {Array}
         */
        get arr() {
            return this._arr;
        }

        /**
         * @readonly
         * @type {number}
         */
        get index() {
            return this._index;
        }

        /**
         * Returns a pair of the element at the current index and rest of the stream.
         * @param {boolean} unicode Will not be considered.
         * @returns {Object}
         */
        uncons() {
            return this._index >= this._arr.length
                ? { empty: true }
                : {
                    empty: false,
                    head : this._arr[this._index],
                    tail : new ArrayStream(this._arr, this._index + 1)
                };
        }
    }

    return end();
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-core / utils.js
 */

/**
 * @module utils
 */



module.exports = () => {
    function end() {
        return Object.freeze({
            show,
            unconsString,
            _internal: {
                escapeChar
            }
        });
    }

    const escapeMap = new Map([
        ["\\", "\\\\"],
        ["\"", "\\\""],
        ["\b", "\\b"],
        ["\f", "\\f"],
        ["\n", "\\n"],
        ["\r", "\\r"],
        ["\t", "\\t"],
        ["\v", "\\v"]
    ]);

    /**
     * @function module:utils.escapeChar
     * @description Escapes the given character `char`.
     * @private
     * @static
     * @param {string} char A character.
     * @returns {string} The escaped character.
     */
    function escapeChar(char) {
        return escapeMap.has(char) ? escapeMap.get(char) : char;
    }

    /**
     * @function module:utils.show
     * @description Pretty-printer for error messages.
     * Printing strategy is determined by the type of `value`.
     * - If `value` is a string, the string is escaped and double-quoted.
     * - If `value` is an string, each element is printed by `show()`
     * then joined with commas `,` and wrapped by braces `[ ... ]`.
     * - If `value` is an object but `value.toString` is not a function,
     * it calls `Object.prototype.toString.call(value)`.
     * - Otherwise, it calls `String(value)`
     * @static
     * @param {*} value Any value.
     * @returns {string} The printed string.
     */
    function show(value) {
        if (typeof value === "string") {
            if (value.length === 1) {
                return `"${escapeChar(value)}"`;
            }
            else {
                return `"${value.replace(/[\u0000-\u001F\\\"]/g, escapeChar)}"`;
            }
        }
        else if (Array.isArray(value)) {
            return `[${value.map(show).join(", ")}]`;
        }
        else if (typeof value === "object" && value !== null && typeof value.toString !== "function") {
            return Object.prototype.toString.call(value);
        }
        else {
            return String(value);
        }
    }

    /**
     * @function module:utils.unconsString
     * @description Reads string.
     * This is a specialized version of {@module:stream.uncons} for string.
     * A result object contains the following properties.
     * <table>
     * <tr><th>Property</th><th>Type</th><th>Description</th></tr>
     * <tr><td>`empty`</td><td>boolean</td><td>Indicates the string is empty or not.
     * If not empty, the object have `head` and `tail` properties.</td></tr>
     * <tr><td>`head`</td><td></td><td>The head of the string.</td></tr>
     * <tr><td>`tail`</td><td>string</td>
     * <td>The tail (rest) of the string.</td></tr>
     * </table>
     * @static
     * @param {string} str A string.
     * @param {boolean} unicode If `true` specified characters are unconsed in code point unit.
     * @returns {Object} An object that have properties describes above.
     */
    function unconsString(str, unicode) {
        const len = str.length;
        if (unicode) {
            if (len === 0) {
                return { empty: true };
            }
            else if (len === 1) {
                return { empty: false, head: str[0], tail: str.substr(1) };
            }
            else {
                const first = str.charCodeAt(0);
                if (first < 0xD800 || 0xDBFF < first) {
                    return { empty: false, head: str[0], tail: str.substr(1) };
                }
                const second = str.charCodeAt(1);
                if (second < 0xDC00 || 0xDFFF < second) {
                    return { empty: false, head: str[0], tail: str.substr(1) };
                }
                return { empty: false, head: String.fromCharCode(first, second), tail: str.substr(2) };
            }
        }
        else {
            return len === 0
                ? { empty: true }
                : { empty: false, head: str[0], tail: str.substr(1) };
        }
    }

    return end();
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-expr
 */



module.exports = _core => {
    const _prim        = __webpack_require__(2)(_core);
    const _combinators = __webpack_require__(4)(_core);
    const _expr        = __webpack_require__(32)(_core, _prim, _combinators);

    return Object.freeze({
        OperatorType         : _expr.OperatorType,
        OperatorAssoc        : _expr.OperatorAssoc,
        Operator             : _expr.Operator,
        buildExpressionParser: _expr.buildExpressionParser
    });
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-expr / expr.js
 */

/**
 * @module expr
 */



module.exports = (_core, _prim, _combinators) => {
    function end() {
        return Object.freeze({
            OperatorType,
            OperatorAssoc,
            Operator,
            buildExpressionParser
        });
    }

    const ParseError = _core.ParseError;
    const Result     = _core.Result;
    const Parser     = _core.Parser;

    const pure     = _prim.pure;
    const bind     = _prim.bind;
    const then     = _prim.then;
    const fail     = _prim.fail;
    const mplus    = _prim.mplus;
    const label    = _prim.label;
    const tryParse = _prim.tryParse;

    const choice = _combinators.choice;

    /**
     * @constant {Object} module:expr.OperatorType
     * @description The `OperatorType` object has string constants describing operator types:
     * - `OperatorType.INFIX = "infix"`
     * - `OperatorType.PREFIX = "prefix"`
     * - `OperatorType.POSTFIX = "postifx"`
     * @static
     */
    const OperatorType = Object.freeze({
        INFIX  : "infix",
        PREFIX : "prefix",
        POSTFIX: "postfix"
    });

    /**
     * @constant {Object} module:expr.OperatorAssoc
     * @description The `OperatorAssoc` object has string constants describing operator associativities:
     * - `OperatorAssoc.NONE = "none"`
     * - `OperatorAssoc.LEFT = "left"`
     * - `OperatorAssoc.RIGHT = "right"`
     * @static
     */
    const OperatorAssoc = Object.freeze({
        NONE : "none",
        LEFT : "left",
        RIGHT: "right"
    });

    /**
     * @static
     */
    class Operator {
        /**
         * @param {string} type
         * @param {AbstractParser} parser
         * @param {(string|undefined)} [assoc=undefined]
         */
        constructor(type, parser, assoc) {
            this._type   = type;
            this._parser = parser;
            this._assoc  = assoc;
        }

        /**
         * @readonly
         * @type {string}
         */
        get type() {
            return this._type;
        }

        /**
         * @readonly
         * @type {AbstractParser}
         */
        get parser() {
            return this._parser;
        }

        /**
         * @readonly
         * @type {(string|undefined)}
         */
        get assoc() {
            return this._assoc;
        }
    }

    /**
     * @private
     * @param {AbstractParser} term
     * @param {Array.<Operator>} ops
     * @returns {AbstractParser}
     */
    function makeParser(term, ops) {
        // collect operators
        const nonAssoc   = [];
        const leftAssoc  = [];
        const rightAssoc = [];
        const prefix     = [];
        const postfix    = [];
        for (const op of ops) {
            switch (op.type) {
            case OperatorType.INFIX:
                switch (op.assoc) {
                case OperatorAssoc.NONE:
                    nonAssoc.push(op.parser);
                    break;
                case OperatorAssoc.LEFT:
                    leftAssoc.push(op.parser);
                    break;
                case OperatorAssoc.RIGHT:
                    rightAssoc.push(op.parser);
                    break;
                default:
                    throw new Error(`unknown operator associativity: ${op.assoc}`);
                }
                break;
            case OperatorType.PREFIX:
                prefix.push(op.parser);
                break;
            case OperatorType.POSTFIX:
                postfix.push(op.parser);
                break;
            default:
                throw new Error(`unknown operator type: ${op.type}`);
            }
        }

        // create operator parsers
        const nassocOp  = choice(nonAssoc);
        const lassocOp  = choice(leftAssoc);
        const rassocOp  = choice(rightAssoc);
        const prefixOp  = label(choice(prefix), "");
        const postfixOp = label(choice(postfix), "");

        // warn ambiguity (always eerr)
        function ambiguous(assoc, parser) {
            return tryParse(
                then(parser, fail(`ambiguous use of a ${assoc} associative operator`))
            );
        }

        const ambiguousNon   = ambiguous("non", nassocOp);
        const ambiguousLeft  = ambiguous("left", lassocOp);
        const ambiguousRight = ambiguous("right", rassocOp);

        // identity
        function id(x) {
            return x;
        }

        // unary operators
        const prefixP  = mplus(prefixOp, pure(id));
        const postfixP = mplus(postfixOp, pure(id));

        // term parser
        const termP = bind(prefixP, pre =>
            bind(term, val =>
                bind(postfixP, post =>
                    pure(post(pre(val)))
                )
            )
        );

        // right assoc binary operator
        function rassocP(x) {
            return mplus(
                bind(rassocOp, f =>
                    bind(bind(termP, rassocP1), y =>
                        pure(f(x, y))
                    )
                ),
                mplus(ambiguousLeft, ambiguousNon)
            );
        }

        function rassocP1(x) {
            return new Parser(state => {
                const vals = [];
                const operations = [];
                let currentState = state;
                let currentErr = ParseError.unknown(state.pos);
                let consumed = false;
                while (true) {
                    const initState = currentState;

                    const opRes = rassocOp.run(currentState);
                    if (opRes.success) {
                        if (opRes.consumed) {
                            consumed = true;
                            operations.push(opRes.val);
                            currentState = opRes.state;
                            currentErr = opRes.err;
                        }
                        else {
                            operations.push(opRes.val);
                            currentState = opRes.state;
                            currentErr = ParseError.merge(currentErr, opRes.err);
                        }
                    }
                    else {
                        if (opRes.consumed) {
                            return opRes;
                        }
                        else {
                            const ambRes = mplus(ambiguousLeft, ambiguousNon).run(initState); // always eerr
                            const err = ParseError.merge(ParseError.merge(currentErr, opRes.err), ambRes.err);
                            let resVal = x;
                            if (vals.length > 0) {
                                let currentVal = vals[vals.length - 1];
                                for (let i = vals.length - 2; i >= 0; i -= 1) {
                                    currentVal = operations[i + 1](vals[i], currentVal);
                                }
                                resVal = operations[0](resVal, currentVal);
                            }
                            return consumed
                                ? Result.csuc(err, resVal, initState)
                                : Result.esuc(err, resVal, initState);
                        }
                    }

                    const termRes = termP.run(currentState);
                    if (termRes.success) {
                        if (termRes.consumed) {
                            consumed = true;
                            vals.push(termRes.val);
                            currentState = termRes.state;
                            currentErr = termRes.err;
                        }
                        else {
                            vals.push(termRes.val);
                            currentState = termRes.state;
                            currentErr = ParseError.merge(currentErr, termRes.err);
                        }
                    }
                    else {
                        if (termRes.consumed) {
                            return termRes;
                        }
                        else {
                            if (opRes.consumed) {
                                return Result.cerr(ParseError.merge(currentErr, termRes.err));
                            }
                            else {
                                const ambRes = mplus(ambiguousLeft, ambiguousNon).run(initState); // always eerr
                                const err = ParseError.merge(ParseError.merge(currentErr, termRes.err), ambRes.err);
                                let resVal = x;
                                if (vals.length > 0) {
                                    let currentVal = vals[vals.length - 1];
                                    for (let i = vals.length - 2; i >= 0; i -= 1) {
                                        currentVal = operations[i + 1](vals[i], currentVal);
                                    }
                                    resVal = operations[0](resVal, currentVal);
                                }
                                return consumed
                                    ? Result.csuc(err, resVal, initState)
                                    : Result.esuc(err, resVal, initState);
                            }
                        }
                    }
                }
            });
        }

        // left assoc binary operator
        function lassocP(x) {
            return mplus(
                bind(lassocOp, f =>
                    bind(termP, y =>
                        lassocP1(f(x, y))
                    )
                ),
                mplus(ambiguousRight, ambiguousNon)
            );
        }

        function lassocP1(x) {
            return new Parser(state => {
                let currentVal = x;
                let currentOperation;
                let currentState = state;
                let currentErr = ParseError.unknown(state.pos);
                let consumed = false;
                while (true) {
                    const initState = currentState;

                    const opRes = lassocOp.run(currentState);
                    if (opRes.success) {
                        if (opRes.consumed) {
                            consumed = true;
                            currentOperation = opRes.val;
                            currentState = opRes.state;
                            currentErr = opRes.err;
                        }
                        else {
                            currentOperation = opRes.val;
                            currentState = opRes.state;
                            currentErr = ParseError.merge(currentErr, opRes.err);
                        }
                    }
                    else {
                        if (opRes.consumed) {
                            return opRes;
                        }
                        else {
                            const ambRes = mplus(ambiguousRight, ambiguousNon).run(initState); // always eerr
                            const err = ParseError.merge(ParseError.merge(currentErr, opRes.err), ambRes.err);
                            return consumed
                                ? Result.csuc(err, currentVal, initState)
                                : Result.esuc(err, currentVal, initState);
                        }
                    }

                    const termRes = termP.run(currentState);
                    if (termRes.success) {
                        if (termRes.consumed) {
                            consumed = true;
                            currentVal = currentOperation(currentVal, termRes.val);
                            currentState = termRes.state;
                            currentErr = termRes.err;
                        }
                        else {
                            currentVal = currentOperation(currentVal, termRes.val);
                            currentState = termRes.state;
                            currentErr = ParseError.merge(currentErr, termRes.err);
                        }
                    }
                    else {
                        if (termRes.consumed) {
                            return termRes;
                        }
                        else {
                            if (opRes.consumed) {
                                return Result.cerr(ParseError.merge(currentErr, termRes.err));
                            }
                            else {
                                const ambRes = mplus(ambiguousRight, ambiguousNon).run(initState); // always eerr
                                const err = ParseError.merge(ParseError.merge(currentErr, termRes.err), ambRes.err);
                                return consumed
                                    ? Result.csuc(err, currentVal, initState)
                                    : Result.esuc(err, currentVal, initState);
                            }
                        }
                    }
                }
            });
        }

        // non assoc binary operator
        function nassocP(x) {
            return bind(nassocOp, f =>
                bind(termP, y =>
                    mplus(
                        mplus(mplus(ambiguousRight, ambiguousLeft), ambiguousNon),
                        pure(f(x, y))
                    )
                )
            );
        }

        return bind(termP, x =>
            label(
                mplus(
                    mplus(mplus(rassocP(x), lassocP(x)), nassocP(x)),
                    pure(x)
                ),
                "operator"
            )
        );
    }

    /**
     * @function module:expr.buildExpressionParser
     * @static
     * @param {Array.<Array.<Operator>>} opTable
     * @param {AbstractParser} atom
     * @returns {AbstractParser}
     */
    function buildExpressionParser(opTable, atom) {
        return opTable.reduce(makeParser, atom);
    }

    return end();
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-monad
 */



module.exports = (_core, opts) => {
    if (opts === undefined) {
        opts = {};
    }

    const _prim  = __webpack_require__(2)(_core);
    const _monad = __webpack_require__(34)(_core, _prim);

    if (opts.sugar) {
        const _sugar = __webpack_require__(35)(_core, _monad);
        _core.extendParser(_sugar);
    }

    return Object.freeze({
        forever    : _monad.forever,
        discard    : _monad.discard,
        void       : _monad.discard,
        join       : _monad.join,
        when       : _monad.when,
        unless     : _monad.unless,
        liftM      : _monad.liftM,
        liftM2     : _monad.liftM2,
        liftM3     : _monad.liftM3,
        liftM4     : _monad.liftM4,
        liftM5     : _monad.liftM5,
        ltor       : _monad.ltor,
        rtol       : _monad.rtol,
        sequence   : _monad.sequence,
        sequence_  : _monad.sequence_,
        mapM       : _monad.mapM,
        mapM_      : _monad.mapM_,
        forM       : _monad.forM,
        forM_      : _monad.forM_,
        filterM    : _monad.filterM,
        zipWithM   : _monad.zipWithM,
        zipWithM_  : _monad.zipWithM_,
        foldM      : _monad.foldM,
        foldM_     : _monad.foldM_,
        replicateM : _monad.replicateM,
        replicateM_: _monad.replicateM_,
        guard      : _monad.guard,
        msum       : _monad.msum,
        mfilter    : _monad.mfilter
    });
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-monad / monad.js
 */

/**
 * @module monad
 */



module.exports = (_core, _prim) => {
    function end() {
        return Object.freeze({
            forever,
            discard,
            join,
            when,
            unless,
            liftM,
            liftM2,
            liftM3,
            liftM4,
            liftM5,
            ltor,
            rtol,
            sequence,
            sequence_,
            mapM,
            mapM_,
            forM,
            forM_,
            filterM,
            zipWithM,
            zipWithM_,
            foldM,
            foldM_,
            replicateM,
            replicateM_,
            guard,
            msum,
            mfilter,
            _internal: {
                zipWith
            }
        });
    }

    const ParseError = _core.ParseError;
    const Result     = _core.Result;
    const Parser     = _core.Parser;

    const map      = _prim.map;
    const pure     = _prim.pure;
    const bind     = _prim.bind;
    const then     = _prim.then;
    const tailRecM = _prim.tailRecM;
    const mzero    = _prim.mzero;
    const mplus    = _prim.mplus;

    /**
     * @function module:monad.forever
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function forever(parser) {
        return tailRecM(
            undefined,
            () => map(parser, () => ({ done: false, value: undefined }))
        );
    }

    /**
     * @function module:monad.discard
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function discard(parser) {
        return map(parser, () => undefined);
    }

    /**
     * @function module:monad.join
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function join(parser) {
        return bind(parser, val => val);
    }

    /**
     * @function module:monad.when
     * @static
     * @param {boolean} cond
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function when(cond, parser) {
        return cond ? parser : pure(undefined);
    }

    /**
     * @function module:monad.unless
     * @static
     * @param {boolean} cond
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function unless(cond, parser) {
        return cond ? pure(undefined) : parser;
    }

    /**
     * @function module:monad.liftM
     * @static
     * @param {function} func
     * @returns {function}
     */
    function liftM(func) {
        return parser => bind(parser, val => pure(func(val)));
    }

    /**
     * @function module:monad.liftM2
     * @static
     * @param {function} func
     * @returns {function}
     */
    function liftM2(func) {
        return (parserA, parserB) =>
            bind(parserA, valA =>
                bind(parserB, valB =>
                    pure(func(valA, valB))
                )
            );
    }

    /**
     * @function module:monad.liftM3
     * @static
     * @param {function} func
     * @returns {function}
     */
    function liftM3(func) {
        return (parserA, parserB, parserC) =>
            bind(parserA, valA =>
                bind(parserB, valB =>
                    bind(parserC, valC =>
                        pure(func(valA, valB, valC))
                    )
                )
            );
    }

    /**
     * @function module:monad.liftM4
     * @static
     * @param {function} func
     * @returns {function}
     */
    function liftM4(func) {
        return (parserA, parserB, parserC, parserD) =>
            bind(parserA, valA =>
                bind(parserB, valB =>
                    bind(parserC, valC =>
                        bind(parserD, valD =>
                            pure(func(valA, valB, valC, valD))
                        )
                    )
                )
            );
    }

    /**
     * @function module:monad.liftM5
     * @static
     * @param {function} func
     * @returns {function}
     */
    function liftM5(func) {
        return (parserA, parserB, parserC, parserD, parserE) =>
            bind(parserA, valA =>
                bind(parserB, valB =>
                    bind(parserC, valC =>
                        bind(parserD, valD =>
                            bind(parserE, valE =>
                                pure(func(valA, valB, valC, valD, valE))
                            )
                        )
                    )
                )
            );
    }

    /**
     * @function module:monad.ltor
     * @static
     * @param {function} funcA
     * @param {function} funcB
     * @returns {function}
     */
    function ltor(funcA, funcB) {
        return val => bind(funcA(val), funcB);
    }

    /**
     * @function module:monad.rtol
     * @static
     * @param {function} funcA
     * @param {function} funcB
     * @returns {function}
     */
    function rtol(funcA, funcB) {
        return val => bind(funcB(val), funcA);
    }

    /**
     * @function module:monad.sequence
     * @static
     * @param {Array.<AbstractParser>} parsers
     * @returns {AbstractParser}
     */
    function sequence(parsers) {
        return new Parser(state => {
            const accum = [];
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;
            for (const parser of parsers) {
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum.push(res.val);
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        accum.push(res.val);
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }
            }
            return consumed
                ? Result.csuc(currentErr, accum, currentState)
                : Result.esuc(currentErr, accum, currentState);
        });
    }

    /**
     * @function module:monad.sequence
     * @static
     * @param {Array.<AbstractParser>} parsers
     * @returns {AbstractParser}
     */
    function sequence_(parsers) {
        return parsers.reduceRight((accum, parser) => then(parser, accum), pure(undefined));
    }

    /**
     * @function module:monad.mapM
     * @static
     * @param {function} func
     * @param {Array} arr
     * @returns {AbstractParser}
     */
    function mapM(func, arr) {
        return sequence(arr.map(elem => func(elem)));
    }

    /**
     * @function module:monad.mapM_
     * @static
     * @param {function} func
     * @param {Array} arr
     * @returns {AbstractParser}
     */
    function mapM_(func, arr) {
        return sequence_(arr.map(elem => func(elem)));
    }

    /**
     * @function module:monad.forM
     * @static
     * @param {Array} arr
     * @param {function} func
     * @returns {AbstractParser}
     */
    function forM(arr, func) {
        return mapM(func, arr);
    }

    /**
     * @function module:monad.forM_
     * @static
     * @param {Array} arr
     * @param {function} func
     * @returns {AbstractParser}
     */
    function forM_(arr, func) {
        return mapM_(func, arr);
    }

    /**
     * @function module:monad.filterM
     * @static
     * @param {function} test
     * @param {Array} arr
     * @returns {AbstractParser}
     */
    function filterM(test, arr) {
        return new Parser(state => {
            const accum = [];
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;
            for (const elem of arr) {
                const parser = test(elem);
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        if (res.val) {
                            accum.push(elem);
                        }
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        if (res.val) {
                            accum.push(elem);
                        }
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }
            }
            return consumed
                ? Result.csuc(currentErr, accum, currentState)
                : Result.esuc(currentErr, accum, currentState);
        });
    }

    /**
     * @function module:monad.zipWith
     * @private
     * @static
     * @param {function} func
     * @param {Array} arrA
     * @param {Array} arrB
     * @returns {*}
     */
    function zipWith(func, arrA, arrB) {
        const res = [];
        const len = Math.min(arrA.length, arrB.length);
        for (let i = 0; i < len; i++) {
            res.push(func(arrA[i], arrB[i]));
        }
        return res;
    }

    /**
     * @function module:monad.zipWithM
     * @static
     * @param {function} func
     * @param {Array} arrA
     * @param {Array} arrB
     * @returns {AbstractParser}
     */
    function zipWithM(func, arrA, arrB) {
        return sequence(zipWith(func, arrA, arrB));
    }

    /**
     * @function module:monad.zipWithM_
     * @static
     * @param {function} func
     * @param {Array} arrA
     * @param {Array} arrB
     * @returns {AbstractParser}
     */
    function zipWithM_(func, arrA, arrB) {
        return sequence_(zipWith(func, arrA, arrB));
    }

    /**
     * @function module:monad.foldM
     * @static
     * @param {function} func
     * @param {*} initVal
     * @param {Array} arr
     * @returns {AbstractParser}
     */
    function foldM(func, initVal, arr) {
        return new Parser(state => {
            let accum = initVal;
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;
            for (const elem of arr) {
                const parser = func(accum, elem);
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum = res.val;
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        accum = res.val;
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }
            }
            return consumed
                ? Result.csuc(currentErr, accum, currentState)
                : Result.esuc(currentErr, accum, currentState);
        });
    }

    /**
     * @function module:monad.foldM_
     * @static
     * @param {function} func
     * @param {*} initVal
     * @param {Array} arr
     * @returns {AbstractParser}
     */
    function foldM_(func, initVal, arr) {
        return then(foldM(func, initVal, arr), pure(undefined));
    }

    /**
     * @function module:monad.replicateM
     * @static
     * @param {number} num
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function replicateM(num, parser) {
        return sequence(new Array(num).fill(parser));
    }

    /**
     * @function module:monad.replicateM_
     * @static
     * @param {number} num
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function replicateM_(num, parser) {
        return sequence_(new Array(num).fill(parser));
    }

    /**
     * @function module:monad.guard
     * @static
     * @param {boolean} cond
     * @returns {AbstractParser}
     */
    function guard(cond) {
        return cond ? pure(undefined) : mzero;
    }

    /**
     * @function module:monad.msum
     * @static
     * @param {Array.<AbstractParser>} parsers
     * @returns {AbstractParser}
     */
    function msum(parsers) {
        return parsers.reduceRight((accum, parser) => mplus(parser, accum), mzero);
    }

    /**
     * @function module:monad.mfilter
     * @static
     * @param {function} test
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function mfilter(test, parser) {
        return bind(parser, val => test(val) ? pure(val) : mzero);
    }

    return end();
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-monad / sugar.js
 */

/**
 * @module sugar
 */



module.exports = (_core, _monad) => {
    const forever = _monad.forever;
    const discard = _monad.discard;
    const join    = _monad.join;
    const when    = _monad.when;
    const unless  = _monad.unless;
    const mfilter = _monad.mfilter;

    return Object.freeze({
        forever: function () {
            return forever(this);
        },
        discard: function () {
            return discard(this);
        },
        void: function () {
            return discard(this);
        },
        join: function () {
            return join(this);
        },
        when: function (cond) {
            return when(cond, this);
        },
        unless: function (cond) {
            return unless(cond, this);
        },
        filter: function (test) {
            return mfilter(test, this);
        }
    });
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-prim / prim.js
 */

/**
 * @module prim
 */



module.exports = _core => {
    function end() {
        return Object.freeze({
            map,
            fmap,
            pure,
            ap,
            left,
            right,
            bind,
            then,
            fail,
            tailRecM,
            ftailRecM,
            mzero,
            mplus,
            label,
            labels,
            hidden,
            unexpected,
            tryParse,
            lookAhead,
            reduceMany,
            many,
            skipMany,
            tokens,
            token,
            tokenPrim,
            getParserState,
            setParserState,
            updateParserState,
            getConfig,
            setConfig,
            getInput,
            setInput,
            getPosition,
            setPosition,
            getState,
            setState
        });
    }

    const ErrorMessageType = _core.ErrorMessageType;
    const ErrorMessage     = _core.ErrorMessage;
    const ParseError       = _core.ParseError;
    const LazyParseError   = _core.LazyParseError;
    const uncons           = _core.uncons;
    const State            = _core.State;
    const Result           = _core.Result;
    const Parser           = _core.Parser;

    /**
     * @function module:prim.map
     * @static
     * @param {AbstractParser} parser
     * @param {function} func
     * @returns {AbstractParser}
     */
    function map(parser, func) {
        return new Parser(state => {
            const res = parser.run(state);
            return res.success
                ? new Result(res.consumed, true, res.err, func(res.val), res.state)
                : res;
        });
    }

    /**
     * @function module:prim.fmap
     * @static
     * @param {function} func
     * @returns {function}
     */
    function fmap(func) {
        return parser => map(parser, func);
    }

    /**
     * @function module:prim.pure
     * @static
     * @param {*} val
     * @returns {AbstractParser}
     */
    function pure(val) {
        return new Parser(state => Result.esuc(ParseError.unknown(state.pos), val, state));
    }

    /**
     * @function module:prim.ap
     * @static
     * @param {AbstractParser} parserA
     * @param {AbstractParser} parserB
     * @returns {AbstractParser}
     */
    function ap(parserA, parserB) {
        return new Parser(state => {
            const resA = parserA.run(state);
            if (resA.success) {
                const func = resA.val;
                const resB = parserB.run(resA.state);
                if (resB.success) {
                    return new Result(
                        resA.consumed || resB.consumed,
                        true,
                        resB.consumed ? resB.err : ParseError.merge(resA.err, resB.err),
                        func(resB.val),
                        resB.state
                    );
                }
                else {
                    return new Result(
                        resA.consumed || resB.consumed,
                        false,
                        resB.consumed ? resB.err : ParseError.merge(resA.err, resB.err)
                    );
                }
            }
            else {
                return resA;
            }
        });
    }

    /**
     * @function module:prim.left
     * @static
     * @param {AbstractParser} parserA
     * @param {AbstractParser} parserB
     * @returns {AbstractParser}
     */
    function left(parserA, parserB) {
        return new Parser(state => {
            const resA = parserA.run(state);
            if (resA.success) {
                const resB = parserB.run(resA.state);
                if (resB.success) {
                    return new Result(
                        resA.consumed || resB.consumed,
                        true,
                        resB.consumed ? resB.err : ParseError.merge(resA.err, resB.err),
                        resA.val,
                        resB.state
                    );
                }
                else {
                    return new Result(
                        resA.consumed || resB.consumed,
                        false,
                        resB.consumed ? resB.err : ParseError.merge(resA.err, resB.err)
                    );
                }
            }
            else {
                return resA;
            }
        });
    }

    /**
     * @function module:prim.right
     * @static
     * @param {AbstractParser} parserA
     * @param {AbstractParser} parserB
     * @returns {AbstractParser}
     */
    function right(parserA, parserB) {
        return new Parser(state => {
            const resA = parserA.run(state);
            if (resA.success) {
                const resB = parserB.run(resA.state);
                if (resB.success) {
                    return new Result(
                        resA.consumed || resB.consumed,
                        true,
                        resB.consumed ? resB.err : ParseError.merge(resA.err, resB.err),
                        resB.val,
                        resB.state
                    );
                }
                else {
                    return new Result(
                        resA.consumed || resB.consumed,
                        false,
                        resB.consumed ? resB.err : ParseError.merge(resA.err, resB.err)
                    );
                }
            }
            else {
                return resA;
            }
        });
    }

    /**
     * @function module:prim.bind
     * @static
     * @param {AbstractParser} parser
     * @param {function} func
     * @returns {AbstractParser}
     */
    function bind(parser, func) {
        return new Parser(state => {
            const resA = parser.run(state);
            if (resA.success) {
                const parserB = func(resA.val);
                const resB = parserB.run(resA.state);
                return resB.consumed
                    ? resB
                    : new Result(
                        resA.consumed,
                        resB.success,
                        ParseError.merge(resA.err, resB.err),
                        resB.val,
                        resB.state
                    );
            }
            else {
                return resA;
            }
        });
    }

    /**
     * @function module:prim.then
     * @static
     * @param {AbstractParser} parserA
     * @param {AbstractParser} parserB
     * @returns {AbstracParser}
     */
    function then(parserA, parserB) {
        return new Parser(state => {
            const resA = parserA.run(state);
            if (resA.success) {
                const resB = parserB.run(resA.state);
                return resB.consumed
                    ? resB
                    : new Result(
                        resA.consumed,
                        resB.success,
                        ParseError.merge(resA.err, resB.err),
                        resB.val,
                        resB.state
                    );
            }
            else {
                return resA;
            }
        });
    }

    /**
     * @function module:prim.fail
     * @static
     * @param {string} msgStr
     * @returns {AbstractParser}
     */
    function fail(msgStr) {
        return new Parser(state => Result.eerr(
            new ParseError(state.pos, [new ErrorMessage(ErrorMessageType.MESSAGE, msgStr)])
        ));
    }

    /**
     * @function module:prim.tailRecM
     * @static
     * @param {*} initVal
     * @param {function} func
     * @returns {AbstractParser}
     */
    function tailRecM(initVal, func) {
        return new Parser(state => {
            let consumed = false;
            let currentVal = initVal;
            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            while (true) {
                const parser = func(currentVal);
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        if (res.val.done) {
                            return Result.csuc(res.err, res.val.value, res.state);
                        }
                        else {
                            consumed = true;
                            currentVal = res.val.value;
                            currentState = res.state;
                            currentErr = res.err;
                        }
                    }
                    else {
                        if (res.val.done) {
                            return consumed
                                ? Result.csuc(ParseError.merge(currentErr, res.err), res.val.value, res.state)
                                : Result.esuc(ParseError.merge(currentErr, res.err), res.val.value, res.state);
                        }
                        else {
                            currentVal = res.val.value;
                            currentState = res.state;
                            currentErr = ParseError.merge(currentErr, res.err);
                        }
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }
            }
        });
    }

    /**
     * @function module:prim.ftailRecM
     * @static
     * @param {function} func
     * @returns {function}
     */
    function ftailRecM(func) {
        return initVal => tailRecM(initVal, func);
    }

    /**
     * @constant module:prim.mzero
     * @static
     * @type {AbstractParser}
     */
    const mzero = new Parser(state => Result.eerr(ParseError.unknown(state.pos)));

    /**
     * @function module:prim.mplus
     * @static
     * @param {AbstractParser} parserA
     * @param {AbstractParser} parserB
     * @returns {AbstractParser}
     */
    function mplus(parserA, parserB) {
        return new Parser(state => {
            const resA = parserA.run(state);
            if (!resA.consumed && !resA.success) {
                const resB = parserB.run(state);
                return resB.consumed
                    ? resB
                    : new Result(
                        resB.consumed,
                        resB.success,
                        ParseError.merge(resA.err, resB.err),
                        resB.val,
                        resB.state
                    );
            }
            else {
                return resA;
            }
        });
    }

    /**
     * @function module:prim.label
     * @static
     * @param {AbstractParser} parser
     * @param {string} labelStr
     * @returns {AbstractParser}
     */
    function label(parser, labelStr) {
        return labels(parser, [labelStr]);
    }

    /**
     * @function module:prim.labels
     * @static
     * @param {AbstractParser} parser
     * @param {Array.<string>} labelStrs
     * @returns {AbstractParser}
     */
    function labels(parser, labelStrs) {
        function setExpects(err) {
            return err.setSpecificTypeMessages(ErrorMessageType.EXPECT, labelStrs.length === 0 ? [""] : labelStrs);
        }
        return new Parser(state => {
            const res = parser.run(state);
            if (res.consumed) {
                return res;
            }
            else {
                return new Result(
                    false,
                    res.success,
                    res.success
                        ? new LazyParseError(() => res.err.isUnknown() ? res.err : setExpects(res.err))
                        : setExpects(res.err),
                    res.val,
                    res.state
                );
            }
        });
    }

    /**
     * @function module:prim.hidden
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function hidden(parser) {
        return label(parser, "");
    }

    /**
     * @function module:prim.unexpected
     * @static
     * @param {string} msgStr
     * @returns {AbstractParser}
     */
    function unexpected(msgStr) {
        return new Parser(state => Result.eerr(
            new ParseError(
                state.pos,
                [new ErrorMessage(ErrorMessageType.UNEXPECT, msgStr)]
            )
        ));
    }

    /**
     * @function module:prim.tryParse
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function tryParse(parser) {
        return new Parser(state => {
            const res = parser.run(state);
            return res.consumed && !res.success
                ? Result.eerr(res.err)
                : res;
        });
    }

    /**
     * @function module:prim.lookAhead
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     */
    function lookAhead(parser) {
        return new Parser(state => {
            const res = parser.run(state);
            return res.success
                ? Result.esuc(ParseError.unknown(state.pos), res.val, state)
                : res;
        });
    }

    /**
     * @function module:prim.reduceMany
     * @static
     * @param {AbstractParser} parser
     * @param {function} callback
     * @param {*} initVal
     * @returns {AbstractParser}
     * @throws {Error} `parser` accepts an empty string.
     */
    function reduceMany(parser, callback, initVal) {
        return new Parser(state => {
            let accum = initVal;
            let consumed = false;
            let currentState = state;
            while (true) {
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum = callback(accum, res.val);
                        currentState = res.state;
                    }
                    else {
                        throw new Error("`many' is applied to a parser that accepts an empty string");
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.csuc(res.err, accum, currentState)
                            : Result.esuc(res.err, accum, currentState);
                    }
                }
            }
        });
    }

    /**
     * @function module:prim.many
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     * @throws {Error} `parser` accepts an empty string.
     */
    function many(parser) {
        return new Parser(state => {
            const accum = [];
            let consumed = false;
            let currentState = state;
            while (true) {
                const res = parser.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        accum.push(res.val);
                        currentState = res.state;
                    }
                    else {
                        throw new Error("`many' is applied to a parser that accepts an empty string");
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.csuc(res.err, accum, currentState)
                            : Result.esuc(res.err, accum, currentState);
                    }
                }
            }
        });
    }

    /**
     * @function module:prim.skipMany
     * @static
     * @param {AbstractParser} parser
     * @returns {AbstractParser}
     * @throws {Error} `parser` accepts an empty string.
     */
    function skipMany(parser) {
        return reduceMany(parser, accum => accum, undefined);
    }

    /**
     * @function module:prim.tokens
     * @static
     * @param {Array.<*>} expectTokens
     * @param {function} tokenEqual
     * @param {function} tokensToString
     * @param {function} calcNextPos
     * @returns {AbstractParser}
     */
    function tokens(expectTokens, tokenEqual, tokensToString, calcNextPos) {
        function eofError(pos) {
            return new ParseError(
                pos,
                [
                    new ErrorMessage(ErrorMessageType.SYSTEM_UNEXPECT, ""),
                    new ErrorMessage(ErrorMessageType.EXPECT, tokensToString(expectTokens))
                ]
            );
        }
        function expectError(pos, token) {
            return new ParseError(
                pos,
                [
                    new ErrorMessage(ErrorMessageType.SYSTEM_UNEXPECT, tokensToString([token])),
                    new ErrorMessage(ErrorMessageType.EXPECT, tokensToString(expectTokens))
                ]
            );
        }
        return new Parser(state => {
            const len = expectTokens.length;
            if (len === 0) {
                return Result.esuc(ParseError.unknown(state.pos), [], state);
            }
            let rest = state.input;
            for (let i = 0; i < len; i++) {
                const unconsed = uncons(rest, state.config.unicode);
                if (unconsed.empty) {
                    return i === 0
                        ? Result.eerr(eofError(state.pos))
                        : Result.cerr(eofError(state.pos));
                }
                else {
                    if (tokenEqual(expectTokens[i], unconsed.head)) {
                        rest = unconsed.tail;
                    }
                    else {
                        return i === 0
                            ? Result.eerr(expectError(state.pos, unconsed.head))
                            : Result.cerr(expectError(state.pos, unconsed.head));
                    }
                }
            }
            const newPos = calcNextPos(state.pos, expectTokens, state.config);
            return Result.csuc(
                ParseError.unknown(newPos),
                expectTokens,
                new State(state.config, rest, newPos, state.userState)
            );
        });
    }

    /**
     * @function module:prim.token
     * @static
     * @param {function} calcValue
     * @param {function} tokenToString
     * @param {function} calcPos
     * @returns {AbstractParser}
     */
    function token(calcValue, tokenToString, calcPos) {
        function calcNextPos(pos, token, rest, config) {
            const unconsed = uncons(rest, config.unicode);
            return unconsed.empty
                ? calcPos(token, config)
                : calcPos(unconsed.head, config);
        }
        return tokenPrim(calcValue, tokenToString, calcNextPos);
    }

    /**
     * @function module:prim.tokenPrim
     * @static
     * @param {function} calcValue
     * @param {function} tokenToString
     * @param {function} calcNextPos
     * @param {function} [calcNextUserState = x => x]
     * @returns {AbstractParser}
     */
    function tokenPrim(calcValue, tokenToString, calcNextPos, calcNextUserState) {
        function systemUnexpectError(pos, str) {
            return new ParseError(
                pos,
                [new ErrorMessage(ErrorMessageType.SYSTEM_UNEXPECT, str)]
            );
        }
        return new Parser(state => {
            const unconsed = uncons(state.input, state.config.unicode);
            if (unconsed.empty) {
                return Result.eerr(systemUnexpectError(state.pos, ""));
            }
            else {
                const maybeVal = calcValue(unconsed.head, state.config);
                if (maybeVal.empty) {
                    return Result.eerr(systemUnexpectError(state.pos, tokenToString(unconsed.head)));
                }
                else {
                    const newPos = calcNextPos(state.pos, unconsed.head, unconsed.tail, state.config);
                    const newUserState = calcNextUserState === undefined
                        ? state.userState
                        : calcNextUserState(state.userState, state.pos, unconsed.head, unconsed.tail, state.config);
                    return Result.csuc(
                        ParseError.unknown(newPos),
                        maybeVal.value,
                        new State(state.config, unconsed.tail, newPos, newUserState)
                    );
                }
            }
        });
    }

    /**
     * @constant module:prim.getParserState
     * @static
     * @type {AbstractParser}
     */
    const getParserState = new Parser(state => Result.esuc(ParseError.unknown(state.pos), state, state));

    /**
     * @function module:prim.setParserState
     * @static
     * @param {State} state
     * @returns {AbstractParser}
     */
    function setParserState(state) {
        return updateParserState(() => state);
    }

    /**
     * @function module:prim.updateParserState
     * @static
     * @param {function} func
     * @returns {AbstractParser}
     */
    function updateParserState(func) {
        return new Parser(state => {
            const newState = func(state);
            return Result.esuc(ParseError.unknown(newState.pos), newState, newState);
        });
    }

    /**
     * @constant module:prim.getConfig
     * @static
     * @type {AbstractParser}
     */
    const getConfig = bind(getParserState, state => pure(state.config));

    /**
     * @function module:prim.setConfig
     * @static
     * @param {Config} config
     * @returns {AbstractParser}
     */
    function setConfig(config) {
        return then(
            updateParserState(state => state.setConfig(config)),
            pure(undefined)
        );
    }

    /**
     * @constant module:prim.getInput
     * @static
     * @type {AbstractParser}
     */
    const getInput = bind(getParserState, state => pure(state.input));

    /**
     * @function module:prim.setInput
     * @static
     * @param {(string|Array|IStream)} input
     * @returns {AbstractParser}
     */
    function setInput(input) {
        return then(
            updateParserState(state => state.setInput(input)),
            pure(undefined)
        );
    }

    /**
     * @constant module:prim.getPosition
     * @static
     * @type {AbstractParser}
     */
    const getPosition = bind(getParserState, state => pure(state.pos));

    /**
     * @function module:prim.setPosition
     * @static
     * @param {SourcePos} pos
     * @returns {AbstractParser}
     */
    function setPosition(pos) {
        return then(
            updateParserState(state => state.setPosition(pos)),
            pure(undefined)
        );
    }

    /**
     * @constant module:prim.getState
     * @static
     * @type {AbstractParser}
     */
    const getState = bind(getParserState, state => pure(state.userState));

    /**
     * @function module:prim.setState
     * @static
     * @param {*} userState
     * @returns {AbstractParser}
     */
    function setState(userState) {
        return then(
            updateParserState(state => state.setUserState(userState)),
            pure(undefined)
        );
    }

    return end();
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-prim / sugar.js
 */

/**
 * @module sugar
 */



module.exports = (_core, _prim) => {
    const isParser = _core.isParser;

    const map        = _prim.map;
    const pure       = _prim.pure;
    const ap         = _prim.ap;
    const left       = _prim.left;
    const right      = _prim.right;
    const bind       = _prim.bind;
    const then       = _prim.then;
    const fail       = _prim.fail;
    const mplus      = _prim.mplus;
    const label      = _prim.label;
    const hidden     = _prim.hidden;
    const tryParse   = _prim.tryParse;
    const lookAhead  = _prim.lookAhead;
    const reduceMany = _prim.reduceMany;
    const many       = _prim.many;
    const skipMany   = _prim.skipMany;

    return Object.freeze({
        map: function (func) {
            return map(this, func);
        },
        return: function (val) {
            return then(this, pure(val));
        },
        ap: function (parser) {
            return ap(this, parser);
        },
        left: function (parser) {
            return left(this, parser);
        },
        skip: function (parser) {
            return left(this, parser);
        },
        right: function (parser) {
            return right(this, parser);
        },
        bind: function (func) {
            return bind(this, func);
        },
        and: function (parser) {
            return then(this, parser);
        },
        fail: function (msgStr) {
            return then(this, fail(msgStr));
        },
        done: function () {
            return map(this, x => ({ done: true, value: x }));
        },
        cont: function () {
            return map(this, x => ({ done: false, value: x }));
        },
        or: function (parser) {
            return mplus(this, parser);
        },
        label: function (labelStr) {
            return label(this, labelStr);
        },
        hidden: function () {
            return hidden(this);
        },
        try: function () {
            return tryParse(this);
        },
        lookAhead: function () {
            return lookAhead(this);
        },
        reduceMany: function (callback, initVal) {
            return reduceMany(this, callback, initVal);
        },
        many: function () {
            return many(this);
        },
        skipMany: function (parser) {
            return isParser(parser)
                ? left(this, skipMany(parser))
                : skipMany(this);
        }
    });
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-qo
 */



module.exports = _core => {
    let _qo = __webpack_require__(39)(_core);

    return Object.freeze({
        qo: _qo.qo,
        do: _qo.qo
    });
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-qo / qo.js
 */

/**
 * @module qo
 */



module.exports = _core => {
    function end() {
        return Object.freeze({
            qo
        });
    }

    const ParseError = _core.ParseError;
    const Result     = _core.Result;
    const Parser     = _core.Parser;
    const isParser   = _core.isParser;

    /**
     * @function module:qo.qo
     * @static
     * @param {GeneratorFunction} genFunc
     * @returns {AbstractParser}
     */
    function qo(genFunc) {
        return new Parser(state => {
            const gen = genFunc();

            let currentState = state;
            let currentErr = ParseError.unknown(state.pos);
            let consumed = false;

            let genRes;
            try {
                genRes = gen.next();
            }
            catch (err) {
                if (isParser(err)) {
                    const errRes = err.run(currentState);
                    if (errRes.success) {
                        return errRes.consumed
                            ? Result.cerr(errRes.err)
                            : Result.eerr(ParseError.merge(currentErr, errRes.err));
                    }
                    else {
                        return errRes.consumed
                            ? errRes
                            : Result.eerr(ParseError.merge(currentErr, errRes.err));
                    }
                }
                else {
                    throw err;
                }
            }

            while (!genRes.done) {
                const res = genRes.value.run(currentState);
                if (res.success) {
                    if (res.consumed) {
                        consumed = true;
                        currentState = res.state;
                        currentErr = res.err;
                    }
                    else {
                        currentState = res.state;
                        currentErr = ParseError.merge(currentErr, res.err);
                    }
                }
                else {
                    if (res.consumed) {
                        return res;
                    }
                    else {
                        return consumed
                            ? Result.cerr(ParseError.merge(currentErr, res.err))
                            : Result.eerr(ParseError.merge(currentErr, res.err));
                    }
                }

                try {
                    genRes = gen.next(res.val);
                }
                catch (err) {
                    if (isParser(err)) {
                        const errRes = err.run(currentState);
                        if (errRes.success) {
                            return errRes.consumed
                                ? Result.cerr(errRes.err)
                                : Result.eerr(ParseError.merge(currentErr, errRes.err));
                        }
                        else {
                            return errRes.consumed
                                ? errRes
                                : Result.eerr(ParseError.merge(currentErr, errRes.err));
                        }
                    }
                    else {
                        throw err;
                    }
                }
            }

            return consumed
                ? Result.csuc(currentErr, genRes.value, currentState)
                : Result.esuc(currentErr, genRes.value, currentState);
        });
    }

    return end();
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-token
 */



module.exports = _core => {
    const _prim        = __webpack_require__(2)(_core);
    const _char        = __webpack_require__(7)(_core);
    const _combinators = __webpack_require__(4)(_core);
    const _language    = __webpack_require__(41)();
    const _token       = __webpack_require__(42)(_core, _prim, _char, _combinators);

    return Object.freeze({
        LanguageDef    : _language.LanguageDef,
        makeTokenParser: _token.makeTokenParser
    });
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-token / language.js
 */

/**
 * @module language
 */



module.exports = () => {
    function end() {
        return Object.freeze({
            LanguageDef
        });
    }

    /**
     * @static
     */
    class LanguageDef {
        /**
         * @param {Object} [obj = {}]
         */
        constructor(obj) {
            if (obj === undefined) {
                obj = {};
            }
            this.commentStart    = obj.commentStart;
            this.commentEnd      = obj.commentEnd;
            this.commentLine     = obj.commentLine;
            this.nestedComments  = obj.nestedComments === undefined ? true : obj.nestedComments;
            this.idStart         = obj.idStart;
            this.idLetter        = obj.idLetter;
            this.opStart         = obj.opStart;
            this.opLetter        = obj.opLetter;
            this.reservedIds     = obj.reservedIds;
            this.reservedOps     = obj.reservedOps;
            this.caseSensitive   = obj.caseSensitive === undefined ? true : obj.caseSensitive;
        }

        /**
         * @returns {module:language.LanguageDef}
         */
        clone() {
            return new LanguageDef({
                commentStart  : this.commentStart,
                commentEnd    : this.commentEnd,
                commentLine   : this.commentLine,
                nestedComments: this.nestedComments,
                idStart       : this.idStart,
                idLetter      : this.idLetter,
                opStart       : this.opStart,
                opLetter      : this.opLetter,
                reservedIds   : this.reservedIds,
                reservedOps   : this.reservedOps,
                caseSensitive : this.caseSensitive
            });
        }
    }

    return end();
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * loquat-token / token.js
 */

/**
 * @module token
 */



module.exports = (_core, _prim, _char, _combinators) => {
    function end() {
        return Object.create({
            makeTokenParser
        });
    }

    const show         = _core.show;
    const unconsString = _core.unconsString;
    const isParser     = _core.isParser;

    const map        = _prim.map;
    const pure       = _prim.pure;
    const bind       = _prim.bind;
    const then       = _prim.then;
    const tailRecM   = _prim.tailRecM;
    const ftailRecM  = _prim.ftailRecM;
    const mplus      = _prim.mplus;
    const label      = _prim.label;
    const unexpected = _prim.unexpected;
    const tryParse   = _prim.tryParse;
    const skipMany   = _prim.skipMany;
    const getConfig  = _prim.getConfig;

    const string     = _char.string;
    const satisfy    = _char.satisfy;
    const oneOf      = _char.oneOf;
    const noneOf     = _char.noneOf;
    const char       = _char.char;
    const space      = _char.space;
    const upper      = _char.upper;
    const digit      = _char.digit;
    const octDigit   = _char.octDigit;
    const hexDigit   = _char.hexDigit;
    const manyChars  = _char.manyChars;
    const manyChars1 = _char.manyChars1;

    const choice        = _combinators.choice;
    const option        = _combinators.option;
    const between       = _combinators.between;
    const many1         = _combinators.many1;
    const skipMany1     = _combinators.skipMany1;
    const sepBy         = _combinators.sepBy;
    const sepBy1        = _combinators.sepBy1;
    const notFollowedBy = _combinators.notFollowedBy;

    /*
     * white space
     */
    const spaceChars  = new Set(" \f\n\r\t\v");
    const simpleSpace = skipMany1(satisfy(char => spaceChars.has(char)));

    function oneLineComment(commentLine) {
        return then(
            tryParse(string(commentLine)),
            then(
                skipMany(satisfy(char => char !== "\n")),
                pure(undefined)
            )
        );
    }

    function multiLineComment(commentStart, commentEnd, nestedComments) {
        const commentStartEnd = commentStart + commentEnd;
        const inCommentMulti = tailRecM(
            undefined,
            () => label(
                mplus(
                    then(
                        tryParse(string(commentEnd)),
                        pure({ done: true, value: undefined })
                    ),
                    mplus(
                        map(comment, () => ({ done: false, value: undefined })),
                        mplus(
                            map(
                                skipMany1(noneOf(commentStartEnd)),
                                () => ({ done: false, value: undefined })
                            ),
                            map(
                                oneOf(commentStartEnd),
                                () => ({ done: false, value: undefined })
                            )
                        )
                    )
                ),
                "end of comment"
            )
        );
        const inCommentSingle = tailRecM(
            undefined,
            () => label(
                mplus(
                    then(
                        tryParse(string(commentEnd)),
                        pure({ done: true, value: undefined })
                    ),
                    mplus(
                        map(
                            skipMany1(noneOf(commentStartEnd)),
                            () => ({ done: false, value: undefined })
                        ),
                        map(
                            oneOf(commentStartEnd),
                            () => ({ done: false, value: undefined })
                        )
                    )
                ),
                "end of comment"
            )
        );
        const inComment = nestedComments ? inCommentMulti : inCommentSingle;
        const comment = then(
            tryParse(string(commentStart)),
            inComment
        );
        return comment;
    }

    /*
     * number literals
     */
    function number(base, baseDigit) {
        return bind(manyChars1(baseDigit), digits => pure(parseInt(digits, base)));
    }
    const decimal     = number(10, digit);
    const hexadecimal = then(oneOf("Xx"), number(16, hexDigit));
    const octal       = then(oneOf("Oo"), number(8, octDigit));

    // natural
    const zeroNumber = label(
        then(
            char("0"),
            mplus(hexadecimal, mplus(octal, mplus(decimal, pure(0))))
        ),
        ""
    );
    const nat = mplus(zeroNumber, decimal);

    // integer
    const sign = mplus(
        then(char("-"), pure(x => -x)),
        mplus(
            then(char("+"), pure(x => x)),
            pure(x => x)
        )
    );

    // float
    const signChar = mplus(char("-"), mplus(char("+"), pure("")));
    const fraction = label(
        then(
            char("."),
            bind(label(manyChars1(digit), "fraction"), digits =>
                pure("." + digits)
            )
        ),
        "fraction"
    );
    const exponent = label(
        then(
            oneOf("Ee"),
            bind(signChar, s =>
                bind(label(decimal, "exponent"), e =>
                    pure("e" + s + e)
                )
            )
        ),
        "exponent"
    );
    function fractExponent(nat) {
        return mplus(
            bind(fraction, fract =>
                bind(option("", exponent), expo =>
                    pure(parseFloat(nat + fract + expo))
                )
            ),
            bind(exponent, expo =>
                pure(parseFloat(nat + expo))
            )
        );
    }
    const floating = bind(manyChars1(digit), fractExponent);

    // natural or float
    function fractFloat(nat) {
        return bind(fractExponent(nat), f =>
            pure({ type: "float", value: f })
        );
    }
    const decimalFloat = bind(manyChars1(digit), nat =>
        option({ type: "natural", value: parseInt(nat, 10) }, fractFloat(nat))
    );
    const zeroNumFloat = mplus(
        bind(mplus(hexadecimal, octal), n =>
            pure({ type: "natural", value: n })
        ),
        mplus(
            decimalFloat,
            mplus(
                fractFloat("0"),
                pure({ type: "natural", value: 0 })
            )
        )
    );
    const natFloat = mplus(
        then(char("0"), zeroNumFloat),
        decimalFloat
    );

    /*
     * character / string literals
     */
    const escMap = {
        "a" : "\u0007",
        "b" : "\b",
        "f" : "\f",
        "n" : "\n",
        "r" : "\r",
        "t" : "\t",
        "v" : "\v",
        "\\": "\\",
        "\"": "\"",
        "'" : "'"
    };
    const asciiMap = {
        "BS" : "\u0008",
        "HT" : "\u0009",
        "LF" : "\u000a",
        "VT" : "\u000b",
        "FF" : "\u000c",
        "CR" : "\u000d",
        "SO" : "\u000e",
        "SI" : "\u000f",
        "EM" : "\u0019",
        "FS" : "\u001c",
        "GS" : "\u001d",
        "RS" : "\u001e",
        "US" : "\u001f",
        "SP" : "\u0020",
        "NUL": "\u0000",
        "SOH": "\u0001",
        "STX": "\u0002",
        "ETX": "\u0003",
        "EOT": "\u0004",
        "ENQ": "\u0005",
        "ACK": "\u0006",
        "BEL": "\u0007",
        "DLE": "\u0010",
        "DC1": "\u0011",
        "DC2": "\u0012",
        "DC3": "\u0013",
        "DC4": "\u0014",
        "NAK": "\u0015",
        "SYN": "\u0016",
        "ETB": "\u0017",
        "CAN": "\u0018",
        "SUB": "\u001a",
        "ESC": "\u001b",
        "DEL": "\u007f"
    };
    const charEsc = choice(
        Object.keys(escMap).sort().map(c =>
            then(char(c), pure(escMap[c]))
        )
    );
    const charNum = bind(
        mplus(
            decimal,
            mplus(
                then(char("o"), number(8, octDigit)),
                then(char("x"), number(16, hexDigit))
            )
        ),
        code => pure(String.fromCharCode(code))
    );
    const charAscii = choice(
        Object.keys(asciiMap).sort().map(asc =>
            tryParse(
                then(string(asc), pure(asciiMap[asc]))
            )
        )
    );
    const charControl = then(
        char("^"),
        bind(upper, code =>
            pure(
                String.fromCharCode(code.charCodeAt(0) - "A".charCodeAt(0) + 1)
            )
        )
    );
    const escapeCode = label(
        mplus(charEsc, mplus(charNum, mplus(charAscii, charControl))),
        "escape code"
    );
    const charLetter = satisfy(c => c !== "'" && c !== "\\" && c > "\u001a");
    const charEscape = then(char("\\"), escapeCode);
    const characterChar = label(
        mplus(charLetter, charEscape),
        "literal character"
    );

    const stringLetter = satisfy(c => c !== "\"" && c !== "\\" && c > "\u001a");
    const escapeGap = then(
        many1(space),
        label(char("\\"), "end of string gap")
    );
    const escapeEmpty = char("&");
    const stringEscape = then(
        char("\\"),
        mplus(
            then(escapeGap, pure("")),
            mplus(
                then(escapeEmpty, pure("")),
                escapeCode
            )
        )
    );
    const stringChar = label(
        mplus(stringLetter, stringEscape),
        "string character"
    );

    /*
     * identifier
     */
    const alpha = new Set("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");

    function alphaToLower(name) {
        return name.replace(/([A-Z])/g, c => c.toLowerCase());
    }

    function caseChar(c) {
        return alpha.has(c)
            ? mplus(
                char(c.toLowerCase()),
                char(c.toUpperCase())
            )
            : char(c);
    }

    function caseString(caseSensitive, str) {
        if (caseSensitive) {
            return string(str);
        }
        const msg = show(str);
        return bind(getConfig, config => {
            const unicode = config.unicode;
            const walk = ftailRecM(str => {
                const unconsed = unconsString(str, unicode);
                return unconsed.empty
                    ? map(pure(undefined), () => ({ done: true, value: undefined }))
                    : map(
                        label(
                            caseChar(unconsed.head),
                            msg
                        ),
                        () => ({ done: false, value: unconsed.tail })
                    );
            });
            return then(walk(str), pure(str));
        });
    }

    /**
     * @function module:token.makeTokenParser
     * @static
     * @param {module:language.LanguageDef} def
     * @returns {Object}
     */
    function makeTokenParser(def) {
        const tp = {};

        /*
         * white space
         */
        const noOneLineComment = def.commentLine === "" || def.commentLine === undefined;
        const noMultiLineComment = def.commentStart === "" || def.commentEnd === ""
            || def.commentStart === undefined || def.commentEnd === undefined;
        const whiteSpace = skipMany(label(
              noOneLineComment && noMultiLineComment ? simpleSpace
            : noOneLineComment ? mplus(
                simpleSpace,
                multiLineComment(def.commentStart, def.commentEnd, def.nestedComments)
            )
            : noMultiLineComment ? mplus(
                simpleSpace,
                oneLineComment(def.commentLine)
            )
            : mplus(
                simpleSpace,
                mplus(
                    oneLineComment(def.commentLine),
                    multiLineComment(def.commentStart, def.commentEnd, def.nestedComments)
                )
            ),
            ""
        ));

        function lexeme(parser) {
            return bind(parser, x => then(whiteSpace, pure(x)));
        }

        function symbol(name) {
            return lexeme(string(name));
        }

        tp.whiteSpace = whiteSpace;
        tp.lexeme     = lexeme;
        tp.symbol     = symbol;

        /*
         * symbols
         */
        const lparen   = symbol("(");
        const rparen   = symbol(")");
        const lbrace   = symbol("{");
        const rbrace   = symbol("}");
        const langle   = symbol("<");
        const rangle   = symbol(">");
        const lbracket = symbol("[");
        const rbracket = symbol("]");

        function parens(parser) {
            return between(lparen, rparen, parser);
        }

        function braces(parser) {
            return between(lbrace, rbrace, parser);
        }

        function angles(parser) {
            return between(langle, rangle, parser);
        }

        function brackets(parser) {
            return between(lbracket, rbracket, parser);
        }

        const semi  = symbol(";");
        const comma = symbol(",");
        const colon = symbol(":");
        const dot   = symbol(".");

        function semiSep(parser) {
            return sepBy(parser, semi);
        }

        function semiSep1(parser) {
            return sepBy1(parser, semi);
        }

        function commaSep(parser) {
            return sepBy(parser, comma);
        }

        function commaSep1(parser) {
            return sepBy1(parser, comma);
        }

        tp.parens    = parens;
        tp.braces    = braces;
        tp.angles    = angles;
        tp.brackets  = brackets;
        tp.semi      = semi;
        tp.comma     = comma;
        tp.colon     = colon;
        tp.dot       = dot;
        tp.semiSep   = semiSep;
        tp.semiSep1  = semiSep1;
        tp.commaSep  = commaSep;
        tp.commaSep1 = commaSep1;

        /*
         * number literals
         */
        const int = bind(lexeme(sign), f =>
            bind(nat, n =>
                pure(f(n))
            )
        );

        const natural        = label(lexeme(nat), "natural");
        const integer        = label(lexeme(int), "integer");
        const float          = label(lexeme(floating), "float");
        const naturalOrFloat = label(lexeme(natFloat), "number");

        tp.decimal        = decimal;
        tp.hexadecimal    = hexadecimal;
        tp.octal          = octal;
        tp.natural        = natural;
        tp.integer        = integer;
        tp.float          = float;
        tp.naturalOrFloat = naturalOrFloat;

        /*
         * character / string literals
         */
        const charLiteral = label(
            lexeme(
                between(
                    char("'"),
                    label(char("'"), "end of character"),
                    characterChar
                )
            ),
            "character"
        );
        const stringLiteral = label(
            lexeme(
                between(
                    char("\""),
                    label(char("\""), "end of string"),
                    manyChars(stringChar)
                )
            ),
            "literal string"
        );

        tp.charLiteral   = charLiteral;
        tp.stringLiteral = stringLiteral;

        /*
         * identifier
         */
        if (isParser(def.idStart) && isParser(def.idLetter)) {
            const idStart  = def.idStart;
            const idLetter = def.idLetter;

            const caseSensitive = def.caseSensitive;

            const reservedIds   = def.reservedIds === undefined ? [] : def.reservedIds;
            const reservedIdSet = new Set(caseSensitive ? reservedIds : reservedIds.map(alphaToLower));
            const isReservedId  = name => reservedIdSet.has(caseSensitive ? name : alphaToLower(name));

            const ident = label(
                bind(idStart, c =>
                    bind(manyChars(idLetter), cs =>
                        pure(c + cs)
                    )
                ),
                "identifier"
            );
            const identifier = lexeme(
                tryParse(
                    bind(ident, name =>
                        isReservedId(name)
                        ? unexpected("reserved word " + show(name))
                        : pure(name)
                    )
                )
            );

            const reserved = name =>
                lexeme(
                    tryParse(
                        then(
                            caseString(caseSensitive, name),
                            label(
                                notFollowedBy(idLetter),
                                "end of " + show(name)
                            )
                        )
                    )
                );

            tp.identifier = identifier;
            tp.reserved   = reserved;
        }

        /*
         * operator
         */
        if (isParser(def.opStart) && isParser(def.opLetter)) {
            const opStart  = def.opStart;
            const opLetter = def.opLetter;

            const reservedOps   = def.reservedOps === undefined ? [] : def.reservedOps;
            const reservedOpSet = new Set(reservedOps);
            const isReservedOp  = name => reservedOpSet.has(name);

            const oper = label(
                bind(opStart, c =>
                    bind(manyChars(opLetter), cs =>
                        pure(c + cs)
                    )
                ),
                "operator"
            );
            const operator = lexeme(
                tryParse(
                    bind(oper, name =>
                        isReservedOp(name)
                        ? unexpected("reserved operator " + show(name))
                        : pure(name)
                    )
                )
            );

            const reservedOp = name =>
                lexeme(
                    tryParse(
                        then(
                            string(name),
                            label(
                                notFollowedBy(opLetter),
                                "end of " + show(name)
                            )
                        )
                    )
                );

            tp.operator   = operator;
            tp.reservedOp = reservedOp;
        }

        return tp;
    }

    return end();
};


/***/ }),
/* 43 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(44)
var ieee754 = __webpack_require__(46)
var isArray = __webpack_require__(47)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(43)))

/***/ }),
/* 46 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 47 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ })
/******/ ]);